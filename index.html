<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>GBL Runner — Mobile Security (Lane Select)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#111a2e;
      --ink:#eaf0ff;
      --muted:#b9c6ff;
      --accent:#64b5ff;
      --good:#39d98a;
      --bad:#ff5c7a;

      --laneA:#7c5cff;
      --laneB:#33d6ff;
      --laneC:#ff7ad9;

      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 500px at 70% 10%, rgba(100,181,255,.18), transparent 55%),
                  radial-gradient(900px 400px at 20% 20%, rgba(124,92,255,.14), transparent 60%),
                  var(--bg);
      color:var(--ink);
      overflow:hidden;
    }
    .wrap{height:100dvh; display:flex; flex-direction:column;}
    header{
      padding:12px 14px 10px;
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
    }
    .brand{display:flex; flex-direction:column; gap:2px; min-width: 260px;}
    .brand .t{font-weight:800; letter-spacing:.2px}
    .brand .s{font-size:12px; color:var(--muted)}
    .hud{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    .pill{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:8px 10px;
      box-shadow: var(--shadow);
      font-size:12px;
      display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(8px);
    }
    .pill b{font-size:13px}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      color:var(--ink);
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:800;
      box-shadow: var(--shadow);
      transition: transform .05s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px)}
    main{flex:1; display:flex; flex-direction:column; gap:10px; padding:0 12px 12px;}
    .topRow{display:flex; gap:10px; align-items:stretch;}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:12px;
      backdrop-filter: blur(10px);
    }
    .qCard{flex: 1.2; min-height:130px; position:relative; overflow:hidden;}
    .qTitle{display:flex; justify-content:space-between; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap;}
    .badge{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(100,181,255,.16);
      border:1px solid rgba(100,181,255,.35);
      white-space:nowrap;
    }
    .qText{font-size:16px; line-height:1.28; font-weight:800;}
    .choices{margin-top:10px; display:grid; grid-template-columns:1fr; gap:6px;}
    .choice{
      display:flex; gap:10px; align-items:center;
      padding:9px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.10);
      font-size:13px;
    }
    .tag{
      width:30px; height:30px; border-radius:10px;
      display:grid; place-items:center;
      font-weight:950;
      color:#0b1220;
    }
    .tag.A{background: var(--laneA)}
    .tag.B{background: var(--laneB)}
    .tag.C{background: var(--laneC)}
    .muted{color:var(--muted)}
    .gameCard{flex: 1.8; padding:10px; display:flex; flex-direction:column; gap:10px;}
    canvas{
      width:100%;
      height: min(54dvh, 520px);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.10));
      box-shadow: var(--shadow);
      touch-action:none;
    }
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      align-items:stretch;
    }
    .ctl{
      border-radius:16px;
      padding:12px 10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      box-shadow: var(--shadow);
      user-select:none;
      display:flex; flex-direction:column; gap:4px;
      align-items:center;
      font-weight:950;
      text-align:center;
    }
    .ctl small{font-weight:700; color:var(--muted); line-height:1.2;}
    .ctl.up{outline:2px solid rgba(124,92,255,.22)}
    .ctl.mid{outline:2px solid rgba(51,214,255,.22)}
    .ctl.down{outline:2px solid rgba(255,122,217,.20)}
    .footerRow{display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between; align-items:center; padding:2px 2px 0;}
    .tiny{font-size:12px; color:var(--muted)}

    .overlay{
      position:fixed; inset:0;
      display:none;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      align-items:center; justify-content:center;
      padding:16px;
      z-index: 50;
    }
    .modal{
      width:min(780px, 96vw);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius:22px;
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      padding:14px;
    }
    .modal h2{margin:6px 0 8px}
    .modal p, .modal li{color:var(--muted)}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; margin-top:12px;}

    .pop{
      position:absolute;
      left:50%; top:54%;
      transform: translate(-50%,-50%);
      padding:12px 14px;
      border-radius:18px;
      font-weight:950;
      display:none;
      z-index: 5;
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      text-align:center;
      min-width: 260px;
    }
    .pop.good{background: rgba(57,217,138,.20);}
    .pop.bad{background: rgba(255,92,122,.18);}
    .pop .why{display:block; margin-top:6px; font-size:12px; color:var(--muted); font-weight:700}

    @media (max-width: 900px){
      .topRow{flex-direction:column}
      canvas{height: min(52dvh, 440px);}
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="t">GBL Runner — Mobile Security</div>
      <div class="s">Pick a lane: A (top) • B (middle) • C (bottom). Keys: ↑/↓ or W/S or A/D</div>
    </div>
    <div class="hud">
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">Accuracy: <b id="acc">0%</b></div>
      <div class="pill">Q: <b id="qnum">0</b>/<span id="qtotal">0</span></div>
      <button class="btn" id="howBtn">How to Play</button>
      <button class="btn" id="restartBtn">Restart</button>
    </div>
  </header>

  <main>
    <div class="topRow">
      <section class="card qCard" aria-live="polite">
        <div class="qTitle">
          <div class="badge" id="topicBadge">Ready</div>
          <div class="tiny muted" id="hint">
            Move lane and choose A/B/C. Gates start after a short reading delay.
          </div>
        </div>
        <div class="qText" id="qText">Press Start to begin.</div>
        <div class="choices" id="choices"></div>
        <div class="pop" id="popup"></div>
      </section>

      <section class="card gameCard">
        <canvas id="c"></canvas>

        <div class="controls">
          <div class="ctl up" id="laneUp" role="button" tabindex="0">▲ Lane Up
            <small>Top = A</small>
          </div>
          <div class="ctl mid" id="confirm" role="button" tabindex="0">Confirm
            <small>Enter / Space</small>
          </div>
          <div class="ctl down" id="laneDown" role="button" tabindex="0">▼ Lane Down
            <small>Bottom = C</small>
          </div>
        </div>

        <div class="footerRow">
          <div class="tiny">Data stored locally • End screen allows CSV download</div>
          <button class="btn" id="startBtn">Start</button>
        </div>
      </section>
    </div>
  </main>
</div>

<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="modalTitle">How to Play</h2>
    <div id="modalBody">
      <ul>
        <li>Each question has three options (A/B/C) mapped to three lanes.</li>
        <li><b>Top lane = A</b>, <b>Middle lane = B</b>, <b>Bottom lane = C</b>.</li>
        <li>Use <b>↑/↓</b> (or <b>W/S</b> or <b>A/D</b>) to change lane.</li>
        <li>Gates start moving after a short reading delay. Your current lane is your answer.</li>
        <li>You may also press <b>Enter/Space</b> to lock your answer early.</li>
      </ul>
    </div>
    <div class="row">
      <button class="btn" id="closeModal">Close</button>
    </div>
  </div>
</div>

<script>
/* =========================
   TUNING (slow + readable)
   ========================= */
const READ_DELAY_MS = 2200;   // time before gates move (reading time)
const GATE_SPEED    = 3.1;    // gate movement speed (lower = slower)

/* =========================
   QUESTION BANK (A/B/C)
   ========================= */
const QUESTION_BANK = [
  {id:"AS01",topic:"Android: Access control",q:"Why enable SIM card lock on Android?",
   A:"To require a PIN before the SIM works after power-on",B:"To boost Wi-Fi speed",C:"To auto-install updates",correct:"A",
   why:"SIM lock prevents SIM use without the PIN after restart."},
  {id:"AS02",topic:"Android: Screen lock",q:"Which screen lock is recommended for stronger security?",
   A:"PIN or Password",B:"No lock for convenience",C:"Wallpaper lock",correct:"A",
   why:"PIN/password can be stronger and longer than patterns."},
  {id:"AS03",topic:"Android: Encryption",q:"On Android 4.0+ what security feature should be turned on?",
   A:"Device encryption",B:"Always-on NFC",C:"Auto caller ID hide",correct:"A",
   why:"Encryption protects stored data if the phone is lost."},
  {id:"AS04",topic:"Android: Network hygiene",q:"What should you turn off by default when not in use?",
   A:"Wi-Fi and Bluetooth",B:"Screen brightness only",C:"Alarm clock",correct:"A",
   why:"Disabling radios reduces exposure and attack surface."},
  {id:"AS05",topic:"Android: NFC",q:"If NFC is on by default, what is the safer practice?",
   A:"Switch it off manually when not needed",B:"Keep it on permanently",C:"Turn off screen lock",correct:"A",
   why:"NFC should not run by default unless required."},
  {id:"SS01",topic:"Smartphones: App install",q:"Safest general place to install apps from is:",
   A:"Official app stores",B:"Random APK sites",C:"Unknown links in messages",correct:"A",
   why:"Official stores reduce (not remove) malware risk."},
  {id:"SS03",topic:"Smartphones: Permissions",q:"If an app requests unnecessary permissions, you should:",
   A:"Be suspicious; consider declining/uninstalling",B:"Always accept to continue",C:"Disable screen lock",correct:"A",
   why:"Unnecessary permissions can indicate data harvesting."},
  {id:"SS06",topic:"Mobile networks",q:"SMS text messages are generally:",
   A:"Sent unencrypted",B:"End-to-end encrypted by default",C:"Encrypted by screen lock",correct:"A",
   why:"SMS is often vulnerable to interception on networks."},
  {id:"SS08",topic:"Secure messaging",q:"Which app is widely used for secure messaging with encryption?",
   A:"Signal",B:"Any SMS app",C:"Caller ID hide feature",correct:"A",
   why:"Signal provides encrypted messages and calls."},
  {id:"IOS01",topic:"iOS: Encryption",q:"On iOS, tying encryption to your data requires you to set a:",
   A:"Passcode / passphrase",B:"Wallpaper",C:"Ringtone",correct:"A",
   why:"Passcode enables data protection mechanisms."},
  {id:"IOS03",topic:"iOS: Backup",q:"In iTunes, which option encrypts backups on your computer?",
   A:"Encrypt backup",B:"Fast sync",C:"Share analytics",correct:"A",
   why:"Backups are not encrypted by default unless enabled."},
  {id:"IOS04",topic:"iOS: Device wipe",q:"A safety feature can erase data after:",
   A:"10 failed passcode attempts",B:"10 minutes of no Wi-Fi",C:"10 missed calls",correct:"A",
   why:"This can protect data during physical attack attempts."},
  {id:"SS07",topic:"Mobile threats",q:"An IMSI catcher can be used to:",
   A:"Pretend to be a cell tower to intercept/track",B:"Improve battery health",C:"Encrypt backups",correct:"A",
   why:"It can trick phones into connecting to it."},
  {id:"SS05",topic:"Encryption reality",q:"Encryption protects data best when the phone is:",
   A:"Powered down/rebooted and not unlocked",B:"Unlocked and in use",C:"On speakerphone",correct:"A",
   why:"Unlocked devices can expose data despite encryption."},
  {id:"AS08",topic:"Android: Updates",q:"Two updates you should regularly check are:",
   A:"OS updates and installed app updates",B:"Wallpaper packs only",C:"Font updates only",correct:"A",
   why:"Updates patch known vulnerabilities."},
];

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

const state = {
  running:false,
  idx:0,
  questions:[],
  score:0,
  correct:0,
  attempted:0,
  current:null,
  lane:1,             // 0=A (top), 1=B (mid), 2=C (bottom)
  locked:false,        // confirm lock
  popUntil:0,
  log:[]
};

// UI
const scoreEl = document.getElementById("score");
const accEl   = document.getElementById("acc");
const qnumEl  = document.getElementById("qnum");
const qtotalEl= document.getElementById("qtotal");
const qTextEl = document.getElementById("qText");
const choicesEl = document.getElementById("choices");
const topicBadge = document.getElementById("topicBadge");
const popupEl = document.getElementById("popup");
const overlay = document.getElementById("overlay");

document.getElementById("closeModal").onclick = ()=> overlay.style.display="none";
document.getElementById("howBtn").onclick = ()=> overlay.style.display="flex";
document.getElementById("restartBtn").onclick = ()=> boot();
document.getElementById("startBtn").onclick = ()=> { if(!state.running) startGame(); };

function updateHUD(){
  scoreEl.textContent = String(state.score);
  const acc = state.attempted ? Math.round((state.correct/state.attempted)*100) : 0;
  accEl.textContent = acc + "%";
  qnumEl.textContent = String(state.attempted);
  qtotalEl.textContent = String(state.questions.length);
}

function renderQuestion(q){
  state.current = q;
  topicBadge.textContent = q.topic;
  qTextEl.textContent = q.q;

  const rows = [
    {k:"A", txt:q.A, cls:"A"},
    {k:"B", txt:q.B, cls:"B"},
    {k:"C", txt:q.C, cls:"C"},
  ];
  choicesEl.innerHTML = rows.map(r => `
    <div class="choice">
      <div class="tag ${r.cls}">${r.k}</div>
      <div><b>${escapeHtml(r.txt)}</b></div>
    </div>
  `).join("");
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

function laneToKey(lane){
  return lane===0 ? "A" : lane===1 ? "B" : "C";
}

function showPopup(ok, correctKey, why){
  popupEl.className = "pop " + (ok ? "good" : "bad");
  popupEl.style.display = "block";
  popupEl.innerHTML = (ok ? "✅ Correct!" : "❌ Wrong!") +
    `<span class="why">Correct: ${correctKey}. ${escapeHtml(why)}</span>`;
  state.popUntil = performance.now() + 950;
}

function hidePopupIfNeeded(now){
  if(popupEl.style.display==="block" && now > state.popUntil){
    popupEl.style.display="none";
  }
}

/* =========================
   CANVAS VISUALS (better runner + lanes)
   ========================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", fitCanvas);

const scene = {
  scroll:0,
  stars:[],
  laneY:[],
  runner:{ x:95, y:0, w:44, h:54, legPhase:0 },
  gates:null,
  phase:"idle",     // "idle" | "reading" | "moving"
  phaseStart:0,
  shakeUntil:0
};

function initScene(){
  fitCanvas();
  const rect = canvas.getBoundingClientRect();
  const w = rect.width, h = rect.height;

  scene.laneY = [h*0.28, h*0.50, h*0.72];
  scene.runner.y = scene.laneY[state.lane];

  scene.stars = [];
  for(let i=0;i<70;i++){
    scene.stars.push({
      x: Math.random()*w,
      y: Math.random()*h*0.6,
      r: 0.6 + Math.random()*1.7,
      s: 0.2 + Math.random()*0.9
    });
  }

  scene.gates = null;
  scene.phase = "idle";
  scene.phaseStart = performance.now();
  scene.shakeUntil = 0;
}

function roundRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function getCss(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

function drawRunner(now){
  const r = scene.runner;
  const w = r.w, h = r.h;
  const x = r.x, y = r.y;

  // smooth lane follow
  const targetY = scene.laneY[state.lane];
  r.y += (targetY - r.y) * 0.18;

  // step animation
  r.legPhase += (scene.phase==="moving" ? 0.22 : 0.08);

  // shadow
  ctx.fillStyle = "rgba(0,0,0,.35)";
  ctx.beginPath();
  ctx.ellipse(x+18, r.y + h/2 + 30, 20, 7, 0, 0, Math.PI*2);
  ctx.fill();

  // outer suit
  const suitGrad = ctx.createLinearGradient(x, y-h/2, x+w, y+h/2);
  suitGrad.addColorStop(0, "rgba(255,255,255,.92)");
  suitGrad.addColorStop(1, "rgba(200,220,255,.80)");
  ctx.fillStyle = suitGrad;
  roundRect(x, r.y-h/2, w, h, 16);
  ctx.fill();

  // suit outline
  ctx.strokeStyle = "rgba(100,181,255,.35)";
  ctx.lineWidth = 2;
  roundRect(x, r.y-h/2, w, h, 16);
  ctx.stroke();

  // helmet visor
  const visor = ctx.createLinearGradient(x+6, r.y-h/2+10, x+w-6, r.y-h/2+24);
  visor.addColorStop(0, "rgba(100,181,255,.75)");
  visor.addColorStop(1, "rgba(124,92,255,.55)");
  ctx.fillStyle = visor;
  roundRect(x+7, r.y-h/2+10, w-14, 14, 9);
  ctx.fill();

  // glow stripe
  ctx.fillStyle = "rgba(255,255,255,.22)";
  roundRect(x+10, r.y-h/2+30, w-20, 8, 6);
  ctx.fill();

  // legs
  const step = Math.sin(r.legPhase) * 7;
  ctx.strokeStyle = "rgba(255,255,255,.88)";
  ctx.lineWidth = 6;
  ctx.lineCap = "round";
  ctx.beginPath(); ctx.moveTo(x+14, r.y+h/2-4); ctx.lineTo(x+14+step, r.y+h/2+14); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x+w-14, r.y+h/2-4); ctx.lineTo(x+w-14-step, r.y+h/2+14); ctx.stroke();

  // small jet sparkle (just visual, not violent)
  if(scene.phase==="moving" && (Math.sin(now/70) > 0.65)){
    ctx.fillStyle = "rgba(255,209,102,.70)";
    ctx.beginPath(); ctx.arc(x-6, r.y+8, 4, 0, Math.PI*2); ctx.fill();
  }
}

function drawScene(now){
  const rect = canvas.getBoundingClientRect();
  const W = rect.width, H = rect.height;

  let shakeX = 0;
  if(now < scene.shakeUntil) shakeX = (Math.random()*2-1) * 2.0;

  ctx.save();
  ctx.translate(shakeX, 0);

  ctx.clearRect(0,0,W,H);

  // starfield
  ctx.fillStyle = "rgba(255,255,255,.80)";
  for(const st of scene.stars){
    const x = (st.x - scene.scroll*st.s*0.35 + W) % W;
    ctx.beginPath();
    ctx.arc(x, st.y, st.r, 0, Math.PI*2);
    ctx.fill();
  }

  // lane guides
  ctx.strokeStyle = "rgba(255,255,255,.10)";
  ctx.lineWidth = 2;
  for(let i=0;i<3;i++){
    ctx.beginPath();
    ctx.moveTo(0, scene.laneY[i]);
    ctx.lineTo(W, scene.laneY[i]);
    ctx.stroke();
  }

  // current lane highlight
  const laneColor = state.lane===0 ? getCss("--laneA") : state.lane===1 ? getCss("--laneB") : getCss("--laneC");
  ctx.fillStyle = laneColor;
  ctx.globalAlpha = 0.12;
  ctx.fillRect(0, scene.laneY[state.lane]-40, W, 80);
  ctx.globalAlpha = 1;

  // ground strip
  const groundY = H*0.84;
  ctx.fillStyle = "rgba(255,255,255,.06)";
  ctx.fillRect(0, groundY, W, H-groundY);

  // moving floor dashes
  scene.scroll += (scene.phase==="moving" ? 2.0 : 0.7);
  ctx.strokeStyle = "rgba(255,255,255,.14)";
  ctx.lineWidth = 6;
  for(let x=-(scene.scroll%90); x<W; x+=90){
    ctx.beginPath();
    ctx.moveTo(x, groundY+24);
    ctx.lineTo(x+38, groundY+24);
    ctx.stroke();
  }

  // gates
  if(scene.gates){
    const g = scene.gates;
    const cols = [
      {k:"A", y: scene.laneY[0], color:getCss("--laneA")},
      {k:"B", y: scene.laneY[1], color:getCss("--laneB")},
      {k:"C", y: scene.laneY[2], color:getCss("--laneC")},
    ];
    for(const c of cols){
      ctx.fillStyle = c.color;
      ctx.globalAlpha = 0.86;
      roundRect(g.x, c.y - g.h/2, g.w, g.h, 16);
      ctx.fill();
      ctx.globalAlpha = 1;

      // label
      ctx.fillStyle = "rgba(11,18,32,.92)";
      ctx.font = "950 22px system-ui,Segoe UI,Arial";
      ctx.fillText(c.k, g.x + g.w/2 - 7, c.y + 8);

      // tiny "Option"
      ctx.fillStyle = "rgba(11,18,32,.70)";
      ctx.font = "800 12px system-ui,Segoe UI,Arial";
      ctx.fillText("Option", g.x + 10, c.y + g.h/2 - 10);
    }
  }

  // runner
  drawRunner(now);

  ctx.restore();
}

/* =========================
   INPUT (lane select)
   ========================= */
function laneUp(){
  if(!state.running) return;
  state.lane = Math.max(0, state.lane - 1);
}
function laneDown(){
  if(!state.running) return;
  state.lane = Math.min(2, state.lane + 1);
}
function confirmLock(){
  if(!state.running) return;
  state.locked = true;
}

document.getElementById("laneUp").addEventListener("pointerdown",(e)=>{ e.preventDefault(); laneUp(); });
document.getElementById("laneDown").addEventListener("pointerdown",(e)=>{ e.preventDefault(); laneDown(); });
document.getElementById("confirm").addEventListener("pointerdown",(e)=>{ e.preventDefault(); confirmLock(); });

window.addEventListener("keydown",(e)=>{
  if(!state.running) return;

  // up/down
  if(e.code==="ArrowUp" || e.code==="KeyW"){ e.preventDefault(); laneUp(); }
  if(e.code==="ArrowDown" || e.code==="KeyS"){ e.preventDefault(); laneDown(); }

  // alternative A/D to move (common for games)
  if(e.code==="KeyA"){ e.preventDefault(); laneUp(); }
  if(e.code==="KeyD"){ e.preventDefault(); laneDown(); }

  // confirm
  if(e.code==="Enter" || e.code==="Space"){ e.preventDefault(); confirmLock(); }
});

/* =========================
   GAME FLOW
   ========================= */
function boot(){
  state.running = false;
  state.idx = 0;
  state.score = 0;
  state.correct = 0;
  state.attempted = 0;
  state.current = null;
  state.lane = 1;
  state.locked = false;
  state.log = [];
  popupEl.style.display = "none";

  const shuffled = shuffle(QUESTION_BANK);
  state.questions = shuffled.slice(0, Math.min(15, shuffled.length));
  qtotalEl.textContent = String(state.questions.length);

  updateHUD();
  topicBadge.textContent = "Ready";
  qTextEl.textContent = "Press Start to begin.";
  choicesEl.innerHTML = "";

  initScene();
}

function startGame(){
  state.running = true;
  document.getElementById("startBtn").textContent = "Running…";
  document.getElementById("startBtn").disabled = true;
  nextQuestion();
}

function nextQuestion(){
  if(state.idx >= state.questions.length){
    endGame();
    return;
  }

  const q = state.questions[state.idx];
  state.idx += 1;
  state.locked = false;

  renderQuestion(q);
  topicBadge.textContent = q.topic;

  // Create gates but keep them paused first (reading phase)
  const rect = canvas.getBoundingClientRect();
  scene.gates = {
    x: rect.width + 30,
    w: Math.max(96, rect.width*0.14),
    h: Math.max(72, rect.height*0.18),
    done:false
  };

  scene.phase = "reading";
  scene.phaseStart = performance.now();
}

function evaluate(){
  const q = state.current;
  const selected = laneToKey(state.lane);
  const correct = q.correct;
  const ok = (selected === correct);

  state.attempted += 1;
  if(ok){
    state.correct += 1;
    state.score += 10;
  } else {
    scene.shakeUntil = performance.now() + 180;
  }
  updateHUD();
  showPopup(ok, correct, q.why);

  // log
  const tNow = new Date().toISOString();
  state.log.push({
    ts:tNow, qid:q.id, topic:q.topic,
    selected, correct,
    is_correct: ok ? 1 : 0,
    score_after: state.score,
    question: q.q
  });
}

function endGame(){
  state.running = false;
  const startBtn = document.getElementById("startBtn");
  startBtn.disabled = false;
  startBtn.textContent = "Start";

  const acc = state.attempted ? Math.round((state.correct/state.attempted)*100) : 0;
  document.getElementById("modalTitle").textContent = "Run Completed";
  document.getElementById("modalBody").innerHTML = `
    <p><b>Score:</b> ${state.score} &nbsp; | &nbsp; <b>Accuracy:</b> ${acc}% &nbsp; | &nbsp; <b>Attempted:</b> ${state.attempted}</p>
    <p class="muted">Download your attempt log as CSV.</p>
    <div class="row" style="justify-content:flex-start; margin-top:10px; gap:10px;">
      <button class="btn" id="dlBtn">Download CSV</button>
      <button class="btn" id="reviewBtn">Review</button>
    </div>
    <div id="reviewArea" style="display:none; margin-top:12px;"></div>
  `;
  overlay.style.display = "flex";

  setTimeout(()=>{
    document.getElementById("dlBtn").onclick = downloadCSV;
    document.getElementById("reviewBtn").onclick = ()=>{
      const ra = document.getElementById("reviewArea");
      ra.style.display = (ra.style.display==="none") ? "block" : "none";
      if(ra.innerHTML.trim()==="") ra.innerHTML = renderReviewHTML();
    };
  },0);

  try{ localStorage.setItem("GBL_RUNNER_LAST_LOG", JSON.stringify(state.log)); }catch(e){}
}

function renderReviewHTML(){
  const byId = new Map(state.questions.map(q => [q.id, q]));
  const items = state.log.map(r=>{
    const q = byId.get(r.qid);
    return `
      <div style="padding:10px; border:1px solid rgba(255,255,255,.12); border-radius:16px; margin:8px 0; background:rgba(0,0,0,.10);">
        <div style="font-weight:950">${escapeHtml(q.q)}</div>
        <div class="muted" style="margin-top:6px; font-size:13px">
          A: ${escapeHtml(q.A)}<br/>
          B: ${escapeHtml(q.B)}<br/>
          C: ${escapeHtml(q.C)}<br/>
          <b>Correct:</b> ${q.correct} &nbsp; | &nbsp; <b>Your lane:</b> ${r.selected} &nbsp; | &nbsp;
          <b>${r.is_correct ? "Correct" : "Wrong"}</b>
          <br/><span class="muted">${escapeHtml(q.why)}</span>
        </div>
      </div>
    `;
  }).join("");
  return `<div style="max-height:260px; overflow:auto; padding-right:6px;">${items}</div>`;
}

function downloadCSV(){
  const rows = [["ts","qid","topic","selected","correct","is_correct","score_after","question"]];
  for(const r of state.log){
    rows.push([r.ts,r.qid,r.topic,r.selected,r.correct,r.is_correct,r.score_after,r.question]);
  }
  const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "GBL_Runner_Log.csv";
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* =========================
   MAIN LOOP
   ========================= */
function tick(now){
  hidePopupIfNeeded(now);

  if(state.running && scene.gates){
    if(scene.phase === "reading"){
      // hold gates during reading time
      if(now - scene.phaseStart >= READ_DELAY_MS){
        scene.phase = "moving";
        scene.phaseStart = now;
      }
    } else if(scene.phase === "moving"){
      // move gates slowly (readable)
      scene.gates.x -= GATE_SPEED;

      // allow early lock: if locked, slow down slightly (gives confidence)
      if(state.locked) scene.gates.x -= 0.7;

      // evaluate at collision point
      const hitX = scene.runner.x + 54;
      if(!scene.gates.done && scene.gates.x <= hitX){
        scene.gates.done = true;
        evaluate();
      }

      // after passing, clear and go next
      if(scene.gates.x < -scene.gates.w - 50){
        scene.gates = null;
        scene.phase = "idle";
        setTimeout(()=>{ if(state.running) nextQuestion(); }, 420);
      }
    }
  }

  drawScene(now);
  requestAnimationFrame(tick);
}

boot();
requestAnimationFrame(tick);
</script>
</body>
</html>
