<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>GBL Mario-Style Platformer v4 — Full Upgrade</title>
  <style>
    :root{
      --bg:#071025;
      --ink:#eaf0ff;
      --muted:#b9c6ff;

      --panel:rgba(255,255,255,.08);
      --border:rgba(255,255,255,.14);
      --shadow:0 12px 34px rgba(0,0,0,.35);

      --good:#39d98a;
      --bad:#ff5c7a;

      --a:#7c5cff;
      --b:#33d6ff;
      --c:#ff7ad9;

      --ground1:#14234a;
      --ground2:#1d3270;
      --grass:#2e65c4;

      --uiBtn:rgba(255,255,255,.08);
      --uiBtnBorder:rgba(255,255,255,.14);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      color:var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1000px 450px at 70% 10%, rgba(100,181,255,.18), transparent 55%),
        radial-gradient(900px 420px at 20% 20%, rgba(124,92,255,.14), transparent 60%),
        var(--bg);
      overflow:hidden;
    }

    .wrap{height:100dvh; display:flex; flex-direction:column;}
    header{
      padding:12px 14px 10px;
      display:flex; gap:10px; justify-content:space-between; align-items:center; flex-wrap:wrap;
    }
    .brand{display:flex; flex-direction:column; gap:2px; min-width:280px;}
    .brand .t{font-weight:900; letter-spacing:.2px}
    .brand .s{font-size:12px; color:var(--muted)}
    .hud{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:8px 10px;
      box-shadow:var(--shadow);
      font-size:12px;
      display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(8px);
      user-select:none;
    }
    .pill b{font-size:13px}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:var(--ink);
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:850;
      box-shadow:var(--shadow);
      user-select:none;
      transition: transform .05s ease;
    }
    .btn:active{transform:translateY(1px)}

    main{flex:1; padding:0 12px 12px; display:flex; flex-direction:column; gap:10px;}
    .row{display:flex; gap:10px; align-items:stretch;}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
      border:1px solid var(--border);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:12px;
      backdrop-filter: blur(10px);
    }

    .qCard{flex:1.2; min-height:150px; position:relative; overflow:hidden;}
    .qTitle{
      display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap;
      margin-bottom:6px;
    }
    .badge{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(100,181,255,.16);
      border:1px solid rgba(100,181,255,.35);
      white-space:nowrap;
      user-select:none;
    }
    .qText{
      font-size:16px;
      line-height:1.28;
      font-weight:900;
      margin-top:6px;
    }
    .choices{margin-top:10px; display:grid; gap:6px;}
    .choice{
      display:flex; gap:10px; align-items:center;
      padding:9px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.10);
      font-size:13px;
      user-select:none;
    }
    .tag{
      width:30px; height:30px; border-radius:10px;
      display:grid; place-items:center;
      font-weight:950; color:#0b1220;
      flex:0 0 auto;
    }
    .tag.A{background:var(--a)}
    .tag.B{background:var(--b)}
    .tag.C{background:var(--c)}
    .muted{color:var(--muted)}

    .gameCard{flex:1.8; display:flex; flex-direction:column; gap:10px; padding:10px;}
    canvas{
      width:100%;
      height:min(56dvh, 560px);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.12));
      box-shadow:var(--shadow);
      touch-action:none;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      align-items:stretch;
    }
    .ctl{
      border-radius:16px;
      padding:14px 10px;
      border:1px solid var(--uiBtnBorder);
      background:var(--uiBtn);
      box-shadow:var(--shadow);
      user-select:none;
      display:flex; flex-direction:column; gap:4px;
      align-items:center;
      font-weight:950;
      text-align:center;
      min-height:56px;
    }
    .ctl small{font-weight:700; color:var(--muted); line-height:1.2;}

    .footerRow{
      display:flex; gap:10px; flex-wrap:wrap;
      justify-content:space-between; align-items:center;
      padding:2px 2px 0;
    }
    .tiny{font-size:12px; color:var(--muted)}

    .pop{
      position:absolute;
      left:50%; top:56%;
      transform:translate(-50%,-50%);
      padding:12px 14px;
      border-radius:18px;
      font-weight:950;
      display:none;
      z-index:5;
      border:1px solid rgba(255,255,255,.14);
      box-shadow:var(--shadow);
      backdrop-filter: blur(8px);
      text-align:center;
      min-width:320px;
      user-select:none;
    }
    .pop.good{background:rgba(57,217,138,.20)}
    .pop.bad{background:rgba(255,92,122,.18)}
    .pop .why{display:block; margin-top:6px; font-size:12px; color:var(--muted); font-weight:750}

    .overlay{
      position:fixed; inset:0;
      display:none;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      align-items:center; justify-content:center;
      padding:16px;
      z-index:50;
    }
    .modal{
      width:min(860px, 96vw);
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius:22px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
      padding:14px;
    }
    .modal h2{margin:6px 0 8px}
    .modal p, .modal li{color:var(--muted)}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; margin-top:12px;}

    @media (max-width: 900px){
      .row{flex-direction:column}
      canvas{height:min(52dvh, 480px);}
      .qText{font-size:15px}
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="t">GBL Platformer v4 — Full Upgrade (Mario-Style)</div>
      <div class="s">Quiz pauses + teleports player under A/B/C bricks • Camera centers on quiz • Coins visibly count</div>
    </div>
    <div class="hud">
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">Coins: <b id="coins">0</b></div>
      <div class="pill">Accuracy: <b id="acc">0%</b></div>
      <div class="pill">Q: <b id="qnum">0</b>/<span id="qtotal">0</span></div>
      <button class="btn" id="howBtn">How to Play</button>
      <button class="btn" id="restartBtn">Restart</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="card qCard" aria-live="polite">
        <div class="qTitle">
          <div class="badge" id="topicBadge">Ready</div>
          <div class="tiny muted">During quiz: jump to hit A/B/C brick. Player always visible.</div>
        </div>
        <div class="qText" id="qText">Press Start to begin.</div>
        <div class="choices" id="choices"></div>
        <div class="pop" id="popup"></div>
      </section>

      <section class="card gameCard">
        <canvas id="c"></canvas>

        <div class="controls">
          <div class="ctl" id="leftBtn" role="button" tabindex="0">◀ Move <small>← / A</small></div>
          <div class="ctl" id="jumpBtn" role="button" tabindex="0">⤒ Jump <small>Space / ↑</small></div>
          <div class="ctl" id="rightBtn" role="button" tabindex="0">Move ▶ <small>→ / D</small></div>
        </div>

        <div class="footerRow">
          <div class="tiny">Coins +1 (visible). Correct +10. No game-over. CSV download at end.</div>
          <button class="btn" id="startBtn">Start</button>
        </div>
      </section>
    </div>
  </main>
</div>

<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="modalTitle">How to Play</h2>
    <div id="modalBody">
      <ul>
        <li>Move with <b>←/→</b> or <b>A/D</b>. Jump with <b>Space</b> or <b>↑</b>. On mobile, use buttons.</li>
        <li>At checkpoints, the run pauses and a question appears.</li>
        <li>Three bricks <b>A/B/C</b> appear. The player is placed under them automatically.</li>
        <li>Jump and hit the brick for your choice. Correct = <b>+10</b>.</li>
        <li>Coins give <b>+1</b> with a visible popup.</li>
        <li>If you do not answer in time, it records <b>NA</b> and continues.</li>
      </ul>
    </div>
    <div class="row">
      <button class="btn" id="closeModal">Close</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   QUESTION BANK (A/B/C). Replace these with your chapter items.
   Keep text short for phone readability.
   ========================================================= */
const QUESTION_BANK = [
  {id:"AS01",topic:"Android",q:"Why enable SIM card lock on Android?",
   A:"Require PIN before SIM works after restart",B:"Boost Wi-Fi speed",C:"Auto-install updates",correct:"A",
   why:"SIM lock blocks SIM use without the PIN after reboot."},

  {id:"AS02",topic:"Android",q:"Which screen lock is stronger?",
   A:"PIN or password",B:"No lock for convenience",C:"Wallpaper lock",correct:"A",
   why:"PIN/password can be stronger and longer than patterns."},

  {id:"SS01",topic:"Smartphone",q:"Safest place to install apps from is:",
   A:"Official app stores",B:"Random APK websites",C:"Unknown links",correct:"A",
   why:"Official stores reduce (not remove) malware risk."},

  {id:"SS03",topic:"Smartphone",q:"If an app asks unnecessary permissions:",
   A:"Decline/uninstall",B:"Always accept",C:"Disable passcode",correct:"A",
   why:"Unnecessary permissions can indicate data harvesting."},

  {id:"IOS01",topic:"iOS",q:"On iOS, encryption is strongest when you set a:",
   A:"Passcode/passphrase",B:"Wallpaper",C:"Ringtone",correct:"A",
   why:"Passcode enables iOS data protection features."},

  {id:"SS06",topic:"Network",q:"SMS messages are generally:",
   A:"Sent unencrypted",B:"End-to-end encrypted",C:"Encrypted by screen lock",correct:"A",
   why:"SMS can be vulnerable to interception."},

  {id:"SS08",topic:"Messaging",q:"A common encrypted messaging app is:",
   A:"Signal",B:"Any SMS app",C:"Caller-ID hiding",correct:"A",
   why:"Signal supports encrypted messages and calls."},

  {id:"IOS04",topic:"iOS",q:"iOS can erase data after:",
   A:"10 failed passcode attempts",B:"10 minutes no Wi-Fi",C:"10 missed calls",correct:"A",
   why:"Reduces risk of repeated passcode guessing."}
];

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}
function getCss(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* =========================================================
   UI
   ========================================================= */
const scoreEl = document.getElementById("score");
const coinsEl = document.getElementById("coins");
const accEl   = document.getElementById("acc");
const qnumEl  = document.getElementById("qnum");
const qtotalEl= document.getElementById("qtotal");
const qTextEl = document.getElementById("qText");
const choicesEl = document.getElementById("choices");
const topicBadge = document.getElementById("topicBadge");
const popupEl = document.getElementById("popup");
const overlay = document.getElementById("overlay");

document.getElementById("closeModal").onclick = ()=> overlay.style.display="none";
document.getElementById("howBtn").onclick = ()=> overlay.style.display="flex";
document.getElementById("restartBtn").onclick = ()=> boot();
document.getElementById("startBtn").onclick = ()=> { if(!state.running) startGame(); };

/* =========================================================
   TUNING (learner-friendly pacing)
   ========================================================= */
const GRAVITY = 0.78;
const JUMP_VEL = -13.8;
const MAX_SPEED = 3.0;
const ACCEL = 0.55;
const GROUND_FRICTION = 0.82;
const AIR_FRICTION = 0.93;

const CAMERA_LERP = 0.12;

const QUESTIONS_PER_RUN = 7;
const QUIZ_TIMEOUT_MS = 9000;
const FEEDBACK_MS = 950;
const SAFE_FALL_Y = 1400;
const LEVEL_END_X = 5200;

/* =========================================================
   LEVEL
   ========================================================= */
function makeLevel(){
  const platforms = [];
  // ground segments with gaps
  platforms.push({x:0,y:430,w:950,h:60});
  platforms.push({x:1030,y:430,w:950,h:60});
  platforms.push({x:2100,y:430,w:950,h:60});
  platforms.push({x:3200,y:430,w:950,h:60});
  platforms.push({x:4350,y:430,w:950,h:60});

  // a few safe upper platforms
  platforms.push({x:520,y:340,w:210,h:22});
  platforms.push({x:1520,y:330,w:250,h:22});
  platforms.push({x:2620,y:325,w:250,h:22});
  platforms.push({x:3780,y:335,w:250,h:22});
  platforms.push({x:4680,y:320,w:230,h:22});

  const checkpoints = [
    {x:640, used:false},
    {x:1540, used:false},
    {x:2660, used:false},
    {x:3820, used:false},
    {x:4700, used:false},
  ];

  const coins = [];
  const coinLine = (x0,y0,n,dx)=>{ for(let i=0;i<n;i++) coins.push({x:x0+i*dx,y:y0,r:9,taken:false}); };
  coinLine(200,380,6,42);
  coinLine(560,300,4,42);
  coinLine(1160,380,6,42);
  coinLine(2280,380,6,42);
  coinLine(3380,380,6,42);
  coinLine(4480,380,6,42);

  return {platforms, checkpoints, coins};
}

/* =========================================================
   STATE
   ========================================================= */
const state = {
  running:false,
  phase:"menu",        // menu | play | quiz | end
  score:0,
  coins:0,
  correct:0,
  attempted:0,
  questions:[],
  qIndex:0,
  current:null,
  quizStart:0,
  log:[],
  popUntil:0,
  cameraX:0,
  lastSafeX:80,
  lastSafeY:280,

  // visuals
  floatPop: [],        // +1, +10 etc
  particles: [],       // sparkles
};

function updateHUD(){
  scoreEl.textContent = String(state.score);
  coinsEl.textContent = String(state.coins);
  const acc = state.attempted ? Math.round((state.correct/state.attempted)*100) : 0;
  accEl.textContent = acc + "%";
  qnumEl.textContent = String(state.attempted);
  qtotalEl.textContent = String(state.questions.length);
}

function renderQuestion(q){
  state.current = q;
  topicBadge.textContent = q.topic;
  qTextEl.textContent = q.q;
  choicesEl.innerHTML = `
    <div class="choice"><div class="tag A">A</div><div><b>${escapeHtml(q.A)}</b></div></div>
    <div class="choice"><div class="tag B">B</div><div><b>${escapeHtml(q.B)}</b></div></div>
    <div class="choice"><div class="tag C">C</div><div><b>${escapeHtml(q.C)}</b></div></div>
  `;
}

function showPopup(ok, correctKey, why){
  popupEl.className = "pop " + (ok ? "good" : "bad");
  popupEl.style.display = "block";
  popupEl.innerHTML = (ok ? "✅ Correct! (+10)" : "❌ Wrong!") +
    `<span class="why">Correct: ${correctKey}. ${escapeHtml(why)}</span>`;
  state.popUntil = performance.now() + FEEDBACK_MS;
}

/* =========================================================
   CANVAS
   ========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", ()=>{ fitCanvas(); initParallax(); });

let stars=[], clouds=[], hills=[];
function initParallax(){
  const rect = canvas.getBoundingClientRect();
  const W = rect.width, H = rect.height;

  stars=[];
  for(let i=0;i<95;i++){
    stars.push({x:Math.random()*W, y:Math.random()*H*0.55, r:0.7+Math.random()*1.7, s:0.25+Math.random()*1.0});
  }
  clouds=[];
  for(let i=0;i<10;i++){
    clouds.push({x:Math.random()*6000, y:42+Math.random()*160, w:130+Math.random()*190, h:30+Math.random()*38, sp:0.06+Math.random()*0.10});
  }
  hills=[];
  for(let i=0;i<9;i++){
    hills.push({x:i*850 + Math.random()*260, y:320+Math.random()*70, w:640+Math.random()*300, h:210+Math.random()*170});
  }
}

let world = makeLevel();

/* Player */
const player = {
  x:80, y:280, w:40, h:54,
  vx:0, vy:0,
  onGround:false,

  // sprite-ish animation
  t:0,
  faceDir:1, // 1 right, -1 left
};

/* Input */
const input = {left:false, right:false, jumpQueued:false};
window.addEventListener("keydown",(e)=>{
  const k=e.code;
  if(["ArrowLeft","ArrowRight","ArrowUp","Space","KeyA","KeyD"].includes(k)) e.preventDefault();
  if(k==="ArrowLeft"||k==="KeyA") input.left=true;
  if(k==="ArrowRight"||k==="KeyD") input.right=true;
  if(k==="ArrowUp"||k==="Space") input.jumpQueued=true;
});
window.addEventListener("keyup",(e)=>{
  const k=e.code;
  if(k==="ArrowLeft"||k==="KeyA") input.left=false;
  if(k==="ArrowRight"||k==="KeyD") input.right=false;
});

/* Mobile buttons */
function bindHold(btn, onDown, onUp){
  btn.addEventListener("pointerdown",(e)=>{ e.preventDefault(); onDown(); });
  btn.addEventListener("pointerup",(e)=>{ e.preventDefault(); onUp(); });
  btn.addEventListener("pointercancel",(e)=>{ e.preventDefault(); onUp(); });
}
bindHold(document.getElementById("leftBtn"), ()=>input.left=true, ()=>input.left=false);
bindHold(document.getElementById("rightBtn"),()=>input.right=true,()=>input.right=false);
document.getElementById("jumpBtn").addEventListener("pointerdown",(e)=>{ e.preventDefault(); input.jumpQueued=true; });

/* Helpers */
function roundRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}
function aabb(a,b){
  return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
}

/* =========================================================
   COLLISIONS
   ========================================================= */
function resolvePlatforms(){
  player.onGround=false;
  for(const pl of world.platforms){
    if(player.x+player.w<pl.x || player.x>pl.x+pl.w) continue;
    if(player.y+player.h<pl.y || player.y>pl.y+pl.h) continue;

    const ox1=(pl.x+pl.w)-player.x;
    const ox2=(player.x+player.w)-pl.x;
    const oy1=(pl.y+pl.h)-player.y;
    const oy2=(player.y+player.h)-pl.y;
    const ox=Math.min(ox1,ox2);
    const oy=Math.min(oy1,oy2);

    if(ox<oy){
      if(player.x<pl.x) player.x-=ox; else player.x+=ox;
      player.vx=0;
    }else{
      if(player.y<pl.y){
        player.y-=oy;
        player.vy=0;
        player.onGround=true;
        state.lastSafeX=player.x;
        state.lastSafeY=player.y;
      }else{
        player.y+=oy;
        player.vy=0;
      }
    }
  }
}

function getGroundYBelowPlayer(){
  const footX = player.x + player.w/2;
  let best = null;
  for(const pl of world.platforms){
    if(pl.temp) continue;
    if(footX < pl.x-2 || footX > pl.x+pl.w+2) continue;
    const top = pl.y;
    if(top >= player.y + player.h - 3 && top <= player.y + player.h + 80){
      if(best === null || top < best) best = top;
    }
  }
  return best ?? 430;
}

/* =========================================================
   VFX: float pop + particles
   ========================================================= */
function addFloatPop(x,y,text,color,ms=650){
  state.floatPop.push({x,y,text,color,until: performance.now()+ms});
}
function addBurst(x,y,baseColor){
  for(let i=0;i<14;i++){
    const ang = Math.random()*Math.PI*2;
    const sp = 1.6 + Math.random()*2.8;
    state.particles.push({
      x,y,
      vx: Math.cos(ang)*sp,
      vy: Math.sin(ang)*sp - 1.2,
      life: 520 + Math.random()*240,
      born: performance.now(),
      color: baseColor,
      r: 1.6 + Math.random()*2.4
    });
  }
}

/* =========================================================
   QUIZ BRICKS (Mario-like bounce, guaranteed visibility)
   ========================================================= */
let quizBricks=[];   // {key,x,y,w,h,hit,bounceUntil}
let quizArea=null;   // {x0,x1}
let quizPad=null;    // temporary platform under player (invisible)

function cleanupQuizSupport(){
  if(quizPad){
    const idx = world.platforms.indexOf(quizPad);
    if(idx>=0) world.platforms.splice(idx,1);
    quizPad=null;
  }
}

function spawnQuizBricks(){
  // stabilize player
  const gy = getGroundYBelowPlayer();
  player.y = gy - player.h;
  player.vy = 0;
  player.onGround = true;

  // temporary pad to avoid edge/pit frustration
  quizPad = {x: player.x - 160, y: gy, w: 520, h: 18, temp:true};
  world.platforms.push(quizPad);

  const bw=58, bh=48, gap=18;

  // choose quiz center near player
  const quizCenterX = player.x + 220;
  const rowY = Math.max(gy - 150, 150);

  const startX = quizCenterX - (bw*3 + gap*2)/2;

  quizBricks = [
    {key:"A", x:startX,              y:rowY, w:bw, h:bh, hit:false, bounceUntil:0},
    {key:"B", x:startX + (bw+gap),   y:rowY, w:bw, h:bh, hit:false, bounceUntil:0},
    {key:"C", x:startX + (bw+gap)*2, y:rowY, w:bw, h:bh, hit:false, bounceUntil:0},
  ];

  // teleport player under B
  const underB = startX + (bw+gap) + bw/2 - player.w/2;
  player.x = underB;
  player.vx = 0;

  // clamp zone
  quizArea = {x0: startX - 160, x1: startX + (bw+gap)*2 + bw + 160};

  // snap camera to quiz zone so player never disappears
  const rect = canvas.getBoundingClientRect();
  const W = rect.width;
  const mid = (quizArea.x0 + quizArea.x1)/2;
  state.cameraX = Math.max(0, mid - W/2);
}

function checkBrickHit(){
  if(state.phase!=="quiz") return;

  const head = {x:player.x+6, y:player.y-6, w:player.w-12, h:10};
  for(const b of quizBricks){
    if(b.hit) continue;

    // bottom band of brick
    const bottom = {x:b.x, y:b.y+b.h-6, w:b.w, h:10};
    if(player.vy < -1 && aabb(head, bottom)){
      b.hit = true;
      b.bounceUntil = performance.now() + 180;
      addBurst(b.x + b.w/2, b.y + b.h, "rgba(255,255,255,.95)");
      handleAnswer(b.key);
      break;
    }
  }
}

function drawBrick(b, now){
  const col = b.key==="A" ? getCss("--a") : b.key==="B" ? getCss("--b") : getCss("--c");
  const t = b.bounceUntil > now ? (1 - (b.bounceUntil - now)/180) : 1;
  const bounce = b.bounceUntil > now ? Math.sin(t*Math.PI)*10 : 0;

  const x = b.x;
  const y = b.y - bounce;
  const w = b.w, h = b.h;

  ctx.save();
  ctx.globalAlpha = b.hit ? 0.30 : 0.98;

  // outer
  const grad = ctx.createLinearGradient(x,y,x,y+h);
  grad.addColorStop(0, col);
  grad.addColorStop(1, "rgba(0,0,0,.10)");
  ctx.fillStyle = grad;
  roundRect(x,y,w,h,10);
  ctx.fill();

  // inner bevel
  ctx.globalAlpha *= 0.65;
  ctx.strokeStyle = "rgba(255,255,255,.55)";
  ctx.lineWidth = 2;
  roundRect(x+3,y+3,w-6,h-6,8);
  ctx.stroke();

  // brick grid texture
  ctx.globalAlpha *= 0.7;
  ctx.strokeStyle = "rgba(7,16,37,.35)";
  ctx.lineWidth = 1.6;
  ctx.beginPath();
  ctx.moveTo(x + w/2, y+7);
  ctx.lineTo(x + w/2, y+h-7);
  ctx.stroke();
  for(let i=1;i<=2;i++){
    ctx.beginPath();
    ctx.moveTo(x+7, y+i*(h/3));
    ctx.lineTo(x+w-7, y+i*(h/3));
    ctx.stroke();
  }

  // label
  ctx.globalAlpha = b.hit ? 0.35 : 1;
  ctx.fillStyle = "rgba(7,16,37,.92)";
  ctx.font = "950 22px system-ui,Segoe UI,Arial";
  ctx.fillText(b.key, x + w/2 - 7, y + 31);

  ctx.restore();
}

/* =========================================================
   QUESTIONS FLOW
   ========================================================= */
function prepareQuestions(){
  const s = shuffle(QUESTION_BANK);
  state.questions = s.slice(0, Math.min(QUESTIONS_PER_RUN, s.length));
  state.qIndex = 0;
  qtotalEl.textContent = String(state.questions.length);
}

function startQuiz(){
  if(state.qIndex >= state.questions.length) return false;

  // ensure stable ground to keep friction low and predictable
  if(!player.onGround) return false;

  const q = state.questions[state.qIndex++];
  renderQuestion(q);

  state.phase = "quiz";
  state.quizStart = performance.now();
  topicBadge.textContent = "Question";

  // freeze drift
  player.vx = 0;

  spawnQuizBricks();

  // timer
  setTimeout(()=>{ if(state.phase==="quiz") autoNoAnswer(); }, QUIZ_TIMEOUT_MS);
  return true;
}

function handleAnswer(selected){
  const q = state.current;
  const ok = (selected === q.correct);

  state.attempted += 1;
  if(ok){
    state.correct += 1;
    state.score += 10;
    addFloatPop(player.x + player.w/2, player.y - 18, "+10", "rgba(57,217,138,.95)", 700);
    addBurst(player.x + player.w/2, player.y, "rgba(57,217,138,.95)");
  }else{
    addBurst(player.x + player.w/2, player.y, "rgba(255,92,122,.95)");
  }

  updateHUD();
  showPopup(ok, q.correct, q.why);

  const rt = Math.max(0, Math.round(performance.now() - state.quizStart));
  state.log.push({
    ts: new Date().toISOString(),
    qid: q.id,
    topic: q.topic,
    selected,
    correct: q.correct,
    is_correct: ok ? 1 : 0,
    response_ms: rt,
    score_after: state.score,
    coins: state.coins
  });

  setTimeout(()=>{
    quizBricks = [];
    quizArea = null;
    cleanupQuizSupport();
    state.phase = "play";
    topicBadge.textContent = "Running";
  }, FEEDBACK_MS + 120);
}

function autoNoAnswer(){
  if(state.phase !== "quiz") return;
  const q = state.current;

  state.attempted += 1;
  updateHUD();
  showPopup(false, q.correct, "No answer recorded.");
  addFloatPop(player.x + player.w/2, player.y - 18, "NA", "rgba(255,255,255,.80)", 700);

  state.log.push({
    ts: new Date().toISOString(),
    qid: q.id,
    topic: q.topic,
    selected: "NA",
    correct: q.correct,
    is_correct: 0,
    response_ms: QUIZ_TIMEOUT_MS,
    score_after: state.score,
    coins: state.coins
  });

  setTimeout(()=>{
    quizBricks = [];
    quizArea = null;
    cleanupQuizSupport();
    state.phase = "play";
    topicBadge.textContent = "Running";
  }, FEEDBACK_MS + 120);
}

/* =========================================================
   DRAWING: upgraded Mario-ish tiles + player sprite + coins
   ========================================================= */
function drawBackground(W,H, now){
  // stars
  ctx.fillStyle="rgba(255,255,255,.88)";
  for(const st of stars){
    const x = (st.x + (state.cameraX*0.10)*st.s) % W;
    const tw = 0.5 + 0.5*Math.sin((now/700) + st.x*0.02);
    ctx.globalAlpha = 0.35 + tw*0.55;
    ctx.beginPath();
    ctx.arc(x, st.y, st.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha=1;

  // hills
  ctx.globalAlpha=0.18;
  ctx.fillStyle="rgba(100,181,255,.90)";
  for(const h of hills){
    const x = h.x - state.cameraX*0.14;
    ctx.beginPath();
    ctx.ellipse(x, h.y, h.w/2, h.h/2, 0, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha=1;

  // clouds
  for(const cl of clouds){
    const cx = cl.x - state.cameraX*cl.sp;
    const wob = Math.sin(now/1100 + cl.x*0.004)*2.0;
    ctx.fillStyle="rgba(255,255,255,.10)";
    roundRect(cx, cl.y + wob, cl.w, cl.h, 20);
    ctx.fill();
  }

  // subtle horizon glow
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,"rgba(255,255,255,.06)");
  g.addColorStop(0.55,"rgba(255,255,255,.00)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);
}

function drawPlatform(pl){
  if(pl.temp) return; // keep quiz pad invisible
  // base
  const base = ctx.createLinearGradient(0, pl.y, 0, pl.y+pl.h);
  base.addColorStop(0, getCss("--ground2"));
  base.addColorStop(1, getCss("--ground1"));
  ctx.fillStyle = base;
  roundRect(pl.x, pl.y, pl.w, pl.h, 16);
  ctx.fill();

  // grass strip
  ctx.fillStyle = getCss("--grass");
  roundRect(pl.x+7, pl.y+7, pl.w-14, 12, 8);
  ctx.fill();

  // pixel-ish tiles pattern
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "white";
  for(let x=pl.x+14; x<pl.x+pl.w-14; x+=34){
    ctx.fillRect(x, pl.y+24, 14, 10);
  }
  ctx.globalAlpha = 1;

  // little edge shading
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = "rgba(0,0,0,.6)";
  ctx.fillRect(pl.x, pl.y+pl.h-10, pl.w, 10);
  ctx.globalAlpha = 1;
}

function drawPlatforms(){
  for(const pl of world.platforms) drawPlatform(pl);
}

function drawCoins(now){
  for(const c of world.coins){
    if(c.taken) continue;
    const wob = Math.sin(now/170 + c.x*0.02)*3.0;
    const spin = 0.35 + 0.65*Math.abs(Math.sin(now/220 + c.x*0.01));
    const rw = c.r * spin;

    // glow
    const glow = ctx.createRadialGradient(c.x, c.y+wob, 2, c.x, c.y+wob, c.r*2.4);
    glow.addColorStop(0,"rgba(255,219,120,.95)");
    glow.addColorStop(1,"rgba(255,219,120,.06)");
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(c.x, c.y+wob, c.r*1.1, 0, Math.PI*2);
    ctx.fill();

    // coin body
    const body = ctx.createLinearGradient(c.x-rw, c.y+wob-c.r, c.x+rw, c.y+wob+c.r);
    body.addColorStop(0,"rgba(255,230,160,.95)");
    body.addColorStop(0.55,"rgba(255,200,80,.95)");
    body.addColorStop(1,"rgba(255,240,190,.90)");
    ctx.fillStyle = body;

    ctx.beginPath();
    ctx.ellipse(c.x, c.y+wob, Math.max(2.5, rw), c.r, 0, 0, Math.PI*2);
    ctx.fill();

    // rim
    ctx.strokeStyle = "rgba(255,255,255,.40)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(c.x, c.y+wob, Math.max(2.5, rw), c.r, 0, 0, Math.PI*2);
    ctx.stroke();

    // shine
    ctx.globalAlpha = 0.30;
    ctx.fillStyle="white";
    ctx.beginPath();
    ctx.ellipse(c.x-3, c.y+wob-4, 3, 4, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawGoal(){
  ctx.strokeStyle="rgba(255,255,255,.55)";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(LEVEL_END_X, 250);
  ctx.lineTo(LEVEL_END_X, 430);
  ctx.stroke();

  ctx.fillStyle="rgba(57,217,138,.90)";
  roundRect(LEVEL_END_X, 260, 86, 44, 12);
  ctx.fill();

  ctx.fillStyle="rgba(7,16,37,.95)";
  ctx.font="900 14px system-ui,Segoe UI,Arial";
  ctx.fillText("FINISH", LEVEL_END_X+14, 288);
}

function drawPlayer(now){
  player.t += 0.12 + Math.min(0.18, Math.abs(player.vx)*0.06);
  if(player.vx > 0.3) player.faceDir = 1;
  if(player.vx < -0.3) player.faceDir = -1;

  // shadow
  ctx.fillStyle="rgba(0,0,0,.32)";
  ctx.beginPath();
  ctx.ellipse(player.x+player.w/2, player.y+player.h+12, 18, 6, 0, 0, Math.PI*2);
  ctx.fill();

  // body (helmet + suit)
  const bx = player.x, by = player.y, bw = player.w, bh = player.h;

  // suit
  const suit = ctx.createLinearGradient(bx,by,bx,bh+by);
  suit.addColorStop(0,"rgba(235,245,255,.95)");
  suit.addColorStop(1,"rgba(170,210,255,.78)");
  ctx.fillStyle = suit;
  roundRect(bx,by,bw,bh,14);
  ctx.fill();

  // belt
  ctx.globalAlpha = 0.55;
  ctx.fillStyle="rgba(7,16,37,.90)";
  roundRect(bx+6, by+bh*0.58, bw-12, 8, 6);
  ctx.fill();
  ctx.globalAlpha = 1;

  // visor
  const v = ctx.createLinearGradient(bx+6,by+10,bx+bw-6,by+28);
  v.addColorStop(0,"rgba(80,220,255,.72)");
  v.addColorStop(1,"rgba(124,92,255,.55)");
  ctx.fillStyle=v;
  roundRect(bx+6,by+12,bw-12,16,10);
  ctx.fill();

  // outline glow
  ctx.strokeStyle="rgba(100,181,255,.42)";
  ctx.lineWidth=2;
  roundRect(bx,by,bw,bh,14);
  ctx.stroke();

  // arms (simple)
  ctx.strokeStyle="rgba(255,255,255,.85)";
  ctx.lineWidth=6;
  ctx.lineCap="round";
  const armSwing = Math.sin(player.t) * 6;
  // left arm
  ctx.beginPath();
  ctx.moveTo(bx+8, by+32);
  ctx.lineTo(bx+6, by+42+armSwing*0.2);
  ctx.stroke();
  // right arm
  ctx.beginPath();
  ctx.moveTo(bx+bw-8, by+32);
  ctx.lineTo(bx+bw-6, by+42-armSwing*0.2);
  ctx.stroke();

  // legs
  const step = Math.sin(player.t) * 7;
  ctx.strokeStyle="rgba(255,255,255,.88)";
  ctx.lineWidth=6;
  ctx.beginPath();
  ctx.moveTo(bx+12, by+bh-6);
  ctx.lineTo(bx+12+step, by+bh+10);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(bx+bw-12, by+bh-6);
  ctx.lineTo(bx+bw-12-step, by+bh+10);
  ctx.stroke();

  // direction indicator (tiny)
  ctx.globalAlpha = 0.25;
  ctx.fillStyle="white";
  if(player.faceDir === 1){
    ctx.beginPath();
    ctx.moveTo(bx+bw+6, by+26);
    ctx.lineTo(bx+bw+18, by+32);
    ctx.lineTo(bx+bw+6, by+38);
    ctx.closePath();
    ctx.fill();
  }else{
    ctx.beginPath();
    ctx.moveTo(bx-6, by+32);
    ctx.lineTo(bx-18, by+26);
    ctx.lineTo(bx-18, by+38);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawFloatPops(now){
  state.floatPop = state.floatPop.filter(p => now < p.until);
  for(const p of state.floatPop){
    const t = 1 - ((p.until - now) / 650);
    ctx.globalAlpha = 1 - t;
    ctx.fillStyle = p.color;
    ctx.font = "900 14px system-ui,Segoe UI,Arial";
    ctx.fillText(p.text, p.x, p.y - t*18);
    ctx.globalAlpha = 1;
  }
}

function drawParticles(now){
  state.particles = state.particles.filter(pt => (now - pt.born) < pt.life);
  for(const pt of state.particles){
    const age = now - pt.born;
    const t = age / pt.life;
    pt.x += pt.vx;
    pt.y += pt.vy;
    pt.vy += 0.06; // gentle gravity
    ctx.globalAlpha = 1 - t;
    ctx.fillStyle = pt.color;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawHUDHint(W,H){
  if(state.phase==="quiz"){
    ctx.fillStyle="rgba(255,255,255,.10)";
    ctx.fillRect(0, H-40, W, 40);
    ctx.fillStyle="rgba(234,240,255,.92)";
    ctx.font="900 12px system-ui,Segoe UI,Arial";
    ctx.fillText("Quiz paused: jump and hit A / B / C brick.", 12, H-16);
  }
}

function draw(now){
  const rect = canvas.getBoundingClientRect();
  const W = rect.width, H = rect.height;

  if(popupEl.style.display==="block" && now > state.popUntil) popupEl.style.display="none";

  ctx.clearRect(0,0,W,H);
  drawBackground(W,H,now);

  // camera transform
  ctx.save();
  ctx.translate(-state.cameraX, 0);

  drawPlatforms();
  drawCoins(now);

  // subtle checkpoint markers
  ctx.globalAlpha = 0.08;
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  for(const cp of world.checkpoints){
    ctx.beginPath();
    ctx.moveTo(cp.x, 240);
    ctx.lineTo(cp.x, 430);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // quiz bricks
  if(state.phase==="quiz"){
    for(const b of quizBricks) drawBrick(b, now);

    if(quizArea){
      ctx.globalAlpha = 0.05;
      ctx.fillStyle="white";
      ctx.fillRect(quizArea.x0, 0, quizArea.x1-quizArea.x0, H);
      ctx.globalAlpha = 1;
    }
  }

  drawGoal();
  drawPlayer(now);

  // particles + float pops (world space)
  drawParticles(now);
  drawFloatPops(now);

  ctx.restore();

  drawHUDHint(W,H);
}

/* =========================================================
   PHYSICS
   ========================================================= */
function physicsStep(now){
  if(!state.running || state.phase==="end") return;

  // movement
  if(state.phase==="play"){
    if(input.left)  player.vx -= ACCEL;
    if(input.right) player.vx += ACCEL;
  } else if(state.phase==="quiz"){
    // allow tiny horizontal correction but keep it stable
    if(input.left)  player.vx -= ACCEL*0.25;
    if(input.right) player.vx += ACCEL*0.25;
  }

  // friction
  if(!input.left && !input.right){
    player.vx *= (player.onGround ? GROUND_FRICTION : AIR_FRICTION);
  }

  // clamp speed
  const cap = (state.phase==="quiz") ? MAX_SPEED*0.25 : MAX_SPEED;
  player.vx = clamp(player.vx, -cap, cap);

  // jump
  if(input.jumpQueued){
    input.jumpQueued = false;
    if(player.onGround){
      player.vy = JUMP_VEL;
      player.onGround = false;
    }
  }

  // gravity
  player.vy += GRAVITY;
  player.vy = Math.min(player.vy, 18);

  // integrate
  player.x += player.vx;
  player.y += player.vy;

  // keep player within world left bound so they never disappear
  player.x = Math.max(0, player.x);

  // quiz clamp
  if(state.phase==="quiz" && quizArea){
    player.x = clamp(player.x, quizArea.x0, quizArea.x1);
    player.vx = 0; // no drift in quiz
  }

  resolvePlatforms();

  // coin pickup (visible)
  for(const c of world.coins){
    if(c.taken) continue;
    const dx=(player.x+player.w/2)-c.x;
    const dy=(player.y+player.h/2)-c.y;
    if(dx*dx + dy*dy < (c.r+18)*(c.r+18)){
      c.taken=true;
      state.coins += 1;
      state.score += 1;
      updateHUD();
      addFloatPop(c.x, c.y-10, "+1", "rgba(255,219,120,.95)", 650);
      addBurst(c.x, c.y, "rgba(255,219,120,.95)");
    }
  }

  // brick hit check
  checkBrickHit();

  // camera
  const rect = canvas.getBoundingClientRect();
  const W = rect.width;

  let target;
  if(state.phase === "quiz" && quizArea){
    const mid = (quizArea.x0 + quizArea.x1) / 2;
    target = mid - W/2;
  } else {
    target = Math.max(0, player.x - 220);
  }
  state.cameraX += (target - state.cameraX) * CAMERA_LERP;
  state.cameraX = Math.max(0, state.cameraX);

  // fall recovery
  if(player.y > SAFE_FALL_Y){
    player.x = state.lastSafeX;
    player.y = state.lastSafeY;
    player.vx = 0; player.vy = 0;
  }

  // checkpoint trigger
  if(state.phase==="play"){
    for(const cp of world.checkpoints){
      if(cp.used) continue;
      if(player.x > cp.x){
        cp.used = true;
        // start quiz only if grounded; if not grounded, allow re-trigger
        if(!startQuiz()){
          cp.used = false;
        }
        break;
      }
    }
  }

  // finish
  if(player.x > LEVEL_END_X + 40){
    endGame();
  }
}

function tick(now){
  physicsStep(now);
  draw(now);
  requestAnimationFrame(tick);
}

/* =========================================================
   START / END / RESET
   ========================================================= */
function boot(){
  state.running=false;
  state.phase="menu";
  state.score=0;
  state.coins=0;
  state.correct=0;
  state.attempted=0;
  state.qIndex=0;
  state.current=null;
  state.log=[];
  state.popUntil=0;
  state.cameraX=0;
  state.floatPop=[];
  state.particles=[];

  world = makeLevel();

  player.x=80; player.y=280; player.vx=0; player.vy=0; player.onGround=false;
  player.t=0; player.faceDir=1;

  quizBricks=[]; quizArea=null;
  cleanupQuizSupport();

  prepareQuestions();
  updateHUD();

  topicBadge.textContent="Ready";
  qTextEl.textContent="Press Start to begin.";
  choicesEl.innerHTML="";
  popupEl.style.display="none";

  document.getElementById("startBtn").disabled=false;
  document.getElementById("startBtn").textContent="Start";
}

function startGame(){
  state.running=true;
  state.phase="play";
  topicBadge.textContent="Running";
  qTextEl.textContent="Run forward. Quiz pauses at checkpoints.";
  choicesEl.innerHTML="";
  document.getElementById("startBtn").disabled=true;
  document.getElementById("startBtn").textContent="Running…";
}

function endGame(){
  state.running=false;
  state.phase="end";
  document.getElementById("startBtn").disabled=false;
  document.getElementById("startBtn").textContent="Start";

  const acc = state.attempted ? Math.round((state.correct/state.attempted)*100) : 0;

  document.getElementById("modalTitle").textContent="Level Completed";
  document.getElementById("modalBody").innerHTML = `
    <p><b>Score:</b> ${state.score} &nbsp; | &nbsp; <b>Coins:</b> ${state.coins} &nbsp; | &nbsp; <b>Accuracy:</b> ${acc}% &nbsp; | &nbsp; <b>Attempted:</b> ${state.attempted}</p>
    <p class="muted">Download CSV for analysis.</p>
    <div class="row" style="justify-content:flex-start; margin-top:10px; gap:10px;">
      <button class="btn" id="dlBtn">Download CSV</button>
      <button class="btn" id="reviewBtn">Review</button>
    </div>
    <div id="reviewArea" style="display:none; margin-top:12px;"></div>
  `;
  overlay.style.display="flex";

  setTimeout(()=>{
    document.getElementById("dlBtn").onclick = downloadCSV;
    document.getElementById("reviewBtn").onclick = ()=>{
      const ra = document.getElementById("reviewArea");
      ra.style.display = (ra.style.display==="none") ? "block" : "none";
      if(ra.innerHTML.trim()==="") ra.innerHTML = renderReviewHTML();
    };
  },0);
}

function renderReviewHTML(){
  const byId = new Map(state.questions.map(q => [q.id, q]));
  const items = state.log.map(r=>{
    const q = byId.get(r.qid);
    if(!q) return "";
    return `
      <div style="padding:10px; border:1px solid rgba(255,255,255,.12); border-radius:16px; margin:8px 0; background:rgba(0,0,0,.10);">
        <div style="font-weight:950">${escapeHtml(q.q)}</div>
        <div class="muted" style="margin-top:6px; font-size:13px">
          A: ${escapeHtml(q.A)}<br/>
          B: ${escapeHtml(q.B)}<br/>
          C: ${escapeHtml(q.C)}<br/>
          <b>Correct:</b> ${q.correct} &nbsp; | &nbsp; <b>Your answer:</b> ${r.selected} &nbsp; | &nbsp;
          <b>${r.is_correct ? "Correct" : "Wrong"}</b>
          <br/><span class="muted">${escapeHtml(q.why)}</span>
        </div>
      </div>
    `;
  }).join("");
  return `<div style="max-height:280px; overflow:auto; padding-right:6px;">${items}</div>`;
}

function downloadCSV(){
  const rows = [["ts","qid","topic","selected","correct","is_correct","response_ms","score_after","coins"]];
  for(const r of state.log){
    rows.push([r.ts,r.qid,r.topic,r.selected,r.correct,r.is_correct,r.response_ms,r.score_after,r.coins]);
  }
  const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download="GBL_Platformer_v4_Log.csv";
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* =========================================================
   INIT
   ========================================================= */
document.getElementById("howBtn").onclick = ()=> overlay.style.display="flex";
document.getElementById("closeModal").onclick = ()=> overlay.style.display="none";
document.getElementById("restartBtn").onclick = ()=> { overlay.style.display="none"; boot(); };
document.getElementById("startBtn").onclick = ()=> { overlay.style.display="none"; if(!state.running) startGame(); };

fitCanvas();
initParallax();
boot();
requestAnimationFrame(tick);
</script>
</body>
</html>
