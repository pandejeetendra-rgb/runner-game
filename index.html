```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>GBL Runner v5 — Low Speed • Spaced Blocks • Better Player</title>
  <style>
    :root{
      --bg:#071025;
      --ink:#eaf0ff;
      --muted:#b9c6ff;
      --panel:rgba(255,255,255,.08);
      --border:rgba(255,255,255,.14);
      --shadow:0 12px 34px rgba(0,0,0,.35);

      --good:#39d98a;
      --bad:#ff5c7a;

      --a:#7c5cff;
      --b:#33d6ff;
      --c:#ff7ad9;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:
        radial-gradient(1000px 450px at 70% 10%, rgba(100,181,255,.18), transparent 55%),
        radial-gradient(900px 420px at 20% 20%, rgba(124,92,255,.14), transparent 60%),
        var(--bg);
      overflow:hidden;
    }

    .wrap{height:100dvh; display:flex; flex-direction:column;}
    header{
      padding:12px 14px 10px;
      display:flex; gap:10px; justify-content:space-between; align-items:center; flex-wrap:wrap;
    }
    .brand{display:flex; flex-direction:column; gap:2px; min-width:280px;}
    .brand .t{font-weight:900;}
    .brand .s{font-size:12px; color:var(--muted)}
    .hud{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      padding:8px 10px;
      box-shadow:var(--shadow);
      font-size:12px;
      display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(8px);
      user-select:none;
    }
    .pill b{font-size:13px}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:var(--ink);
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:850;
      box-shadow:var(--shadow);
      user-select:none;
      transition: transform .05s ease;
    }
    .btn:active{transform:translateY(1px)}

    main{flex:1; padding:0 12px 12px; display:flex; flex-direction:column; gap:10px;}
    .row{display:flex; gap:10px; align-items:stretch;}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
      border:1px solid var(--border);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:12px;
      backdrop-filter: blur(10px);
    }
    .qCard{flex:1.2; min-height:150px; position:relative; overflow:hidden;}
    .qTitle{display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; margin-bottom:6px;}
    .badge{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(100,181,255,.16);
      border:1px solid rgba(100,181,255,.35);
      white-space:nowrap;
      user-select:none;
    }
    .qText{font-size:16px; line-height:1.28; font-weight:900; margin-top:6px;}
    .choices{margin-top:10px; display:grid; gap:6px;}
    .choice{
      display:flex; gap:10px; align-items:center;
      padding:9px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.10);
      font-size:13px;
      user-select:none;
    }
    .tag{
      width:30px; height:30px; border-radius:10px;
      display:grid; place-items:center;
      font-weight:950; color:#0b1220;
      flex:0 0 auto;
    }
    .tag.A{background:var(--a)}
    .tag.B{background:var(--b)}
    .tag.C{background:var(--c)}
    .muted{color:var(--muted)}

    .gameCard{flex:1.8; display:flex; flex-direction:column; gap:10px; padding:10px;}
    canvas{
      width:100%;
      height:min(56dvh, 560px);
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.12));
      box-shadow:var(--shadow);
      touch-action:none;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
      align-items:stretch;
    }
    .ctl{
      border-radius:16px;
      padding:14px 10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      box-shadow:var(--shadow);
      user-select:none;
      display:flex; flex-direction:column; gap:4px;
      align-items:center;
      font-weight:950;
      text-align:center;
      min-height:56px;
    }
    .ctl small{font-weight:700; color:var(--muted); line-height:1.2;}
    .footerRow{
      display:flex; gap:10px; flex-wrap:wrap;
      justify-content:space-between; align-items:center;
      padding:2px 2px 0;
    }
    .tiny{font-size:12px; color:var(--muted)}

    .pop{
      position:absolute;
      left:50%; top:56%;
      transform:translate(-50%,-50%);
      padding:12px 14px;
      border-radius:18px;
      font-weight:950;
      display:none;
      z-index:5;
      border:1px solid rgba(255,255,255,.14);
      box-shadow:var(--shadow);
      backdrop-filter: blur(8px);
      text-align:center;
      min-width:320px;
      user-select:none;
    }
    .pop.good{background:rgba(57,217,138,.20)}
    .pop.bad{background:rgba(255,92,122,.18)}
    .pop .why{display:block; margin-top:6px; font-size:12px; color:var(--muted); font-weight:750}

    .overlay{
      position:fixed; inset:0;
      display:none;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      align-items:center; justify-content:center;
      padding:16px;
      z-index:50;
    }
    .modal{
      width:min(860px, 96vw);
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius:22px;
      box-shadow:0 20px 60px rgba(0,0,0,.55);
      padding:14px;
    }
    .modal h2{margin:6px 0 8px}
    .modal p, .modal li{color:var(--muted)}
    .modal .row{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; margin-top:12px;}

    @media (max-width: 900px){
      .row{flex-direction:column}
      canvas{height:min(52dvh, 480px);}
      .qText{font-size:15px}
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="t">GBL Runner v5 — Simple Logic (Low Speed + Spaced Options)</div>
      <div class="s">Answer by colliding with the correct block • Jump over incorrect ones • Always visible on any screen</div>
    </div>
    <div class="hud">
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">Coins: <b id="coins">0</b></div>
      <div class="pill">Accuracy: <b id="acc">0%</b></div>
      <div class="pill">Q: <b id="qnum">0</b>/<span id="qtotal">0</span></div>
      <button class="btn" id="howBtn">How to Play</button>
      <button class="btn" id="restartBtn">Restart</button>
    </div>
  </header>

  <main>
    <div class="row">
      <section class="card qCard" aria-live="polite">
        <div class="qTitle">
          <div class="badge" id="topicBadge">Ready</div>
          <div class="tiny muted">During question: collide with correct A/B/C block, jump over wrong ones.</div>
        </div>
        <div class="qText" id="qText">Press Start to begin.</div>
        <div class="choices" id="choices"></div>
        <div class="pop" id="popup"></div>
      </section>

      <section class="card gameCard">
        <canvas id="c"></canvas>

        <div class="controls">
          <div class="ctl" id="leftBtn" role="button" tabindex="0">◀ Adjust <small>← / A</small></div>
          <div class="ctl" id="jumpBtn" role="button" tabindex="0">⤒ Jump <small>Space / ↑</small></div>
          <div class="ctl" id="rightBtn" role="button" tabindex="0">Adjust ▶ <small>→ / D</small></div>
        </div>

        <div class="footerRow">
          <div class="tiny">Low speed • Big readable questions • Options are spaced with safe landing gaps</div>
          <button class="btn" id="startBtn">Start</button>
        </div>
      </section>
    </div>
  </main>
</div>

<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="modalTitle">How to Play</h2>
    <div id="modalBody">
      <ul>
        <li>The runner moves forward slowly.</li>
        <li>Each question shows three option blocks A/B/C (spaced apart).</li>
        <li><b>Goal:</b> collide with the correct option block. Jump over incorrect ones.</li>
        <li>Jump: <b>Space</b> or <b>↑</b> (mobile: Jump button). You can also slightly adjust left/right.</li>
        <li>Correct = <b>+10</b>. Wrong = <b>0</b> (and it moves to next question).</li>
        <li>At end, you can download a CSV log for analysis.</li>
      </ul>
    </div>
    <div class="row">
      <button class="btn" id="closeModal">Close</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   QUESTIONS
   Replace these with your chapter-based questions.
   Keep options short for phone readability.
   ========================================================= */
const QUESTION_BANK = [
  {id:"Q1",topic:"Mobile Security",q:"Safest place to install apps is:",
   A:"Official app stores",B:"Random APK sites",C:"Unknown message links",correct:"A",
   why:"Official stores reduce (not remove) malware risk."},
  {id:"Q2",topic:"Android",q:"Why enable SIM lock?",
   A:"PIN needed after restart",B:"Faster internet",C:"Auto updates",correct:"A",
   why:"SIM lock blocks SIM use without the PIN after reboot."},
  {id:"Q3",topic:"Permissions",q:"If an app asks unnecessary permissions:",
   A:"Decline/uninstall",B:"Always accept",C:"Turn off screen lock",correct:"A",
   why:"Unnecessary permissions can indicate data harvesting."},
  {id:"Q4",topic:"Messaging",q:"SMS messages are generally:",
   A:"Unencrypted",B:"End-to-end encrypted",C:"Encrypted by passcode",correct:"A",
   why:"SMS can be vulnerable to interception."},
  {id:"Q5",topic:"iOS",q:"iOS data protection is strongest with a:",
   A:"Passcode",B:"Wallpaper",C:"Ringtone",correct:"A",
   why:"Passcode enables iOS data protection features."},
  {id:"Q6",topic:"Secure chat",q:"An encrypted messaging app is:",
   A:"Signal",B:"Any SMS app",C:"Caller ID hide",correct:"A",
   why:"Signal supports encrypted messages and calls."},
];

/* =========================================================
   Utilities
   ========================================================= */
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function css(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

/* =========================================================
   UI refs
   ========================================================= */
const scoreEl = document.getElementById("score");
const coinsEl = document.getElementById("coins");
const accEl   = document.getElementById("acc");
const qnumEl  = document.getElementById("qnum");
const qtotalEl= document.getElementById("qtotal");
const qTextEl = document.getElementById("qText");
const choicesEl = document.getElementById("choices");
const topicBadge = document.getElementById("topicBadge");
const popupEl = document.getElementById("popup");
const overlay = document.getElementById("overlay");
const modalTitle = document.getElementById("modalTitle");
const modalBody  = document.getElementById("modalBody");

document.getElementById("howBtn").onclick = ()=> overlay.style.display="flex";
document.getElementById("closeModal").onclick = ()=> overlay.style.display="none";

/* =========================================================
   Canvas
   ========================================================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function fitCanvas(){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener("resize", ()=>{ fitCanvas(); initSky(); });

/* =========================================================
   Game tuning (LOW SPEED + SAFE SPACING)
   ========================================================= */
const READ_PAUSE_MS = 1200;   // freeze runner to read
const RUN_SPEED = 2.0;        // low speed (world px per frame-ish)
const GRAVITY = 0.85;
const JUMP_VEL = -14.0;
const AIR_CONTROL = 0.20;     // small left/right adjust
const GROUND_CONTROL = 0.45;

const QUESTION_TIMEOUT_MS = 13000;
const FEEDBACK_MS = 950;

const BLOCK_HIT_MARGIN = 6;   // forgiveness
const QUESTIONS_PER_RUN = 6;

/* =========================================================
   Responsive world (NO hard-coded 430)
   ========================================================= */
function getWorldMetrics(){
  const rect = canvas.getBoundingClientRect();
  const W = rect.width;
  const H = rect.height;

  const groundThickness = clamp(Math.round(H*0.12), 46, 72);
  const groundY = H - groundThickness;

  const playerH = clamp(Math.round(H*0.12), 54, 82);
  const playerW = Math.round(playerH*0.72);

  return {W,H,groundY,groundThickness,playerW,playerH};
}

/* =========================================================
   Sky decor
   ========================================================= */
let stars=[];
function initSky(){
  const {W,H} = getWorldMetrics();
  stars=[];
  for(let i=0;i<90;i++){
    stars.push({x:Math.random()*W, y:Math.random()*H*0.70, r:0.8+Math.random()*1.6, tw:Math.random()*6.28});
  }
}

/* =========================================================
   State
   ========================================================= */
const state = {
  running:false,
  phase:"menu", // menu | run | question | feedback | end
  score:0,
  coins:0,
  correct:0,
  attempted:0,

  questions:[],
  qIndex:0,
  current:null,

  cameraX:0,
  worldX:0, // player world position x (continuous forward)

  readUntil:0,
  questionStart:0,

  blocks:[], // active option blocks for current question
  answered:false,

  floatPop:[],
  particles:[],

  log:[]
};

function updateHUD(){
  scoreEl.textContent = String(state.score);
  coinsEl.textContent = String(state.coins);
  const acc = state.attempted ? Math.round((state.correct/state.attempted)*100) : 0;
  accEl.textContent = acc + "%";
  qnumEl.textContent = String(state.attempted);
  qtotalEl.textContent = String(state.questions.length);
}

/* =========================================================
   Player
   ========================================================= */
const player = {
  x:120, y:0,
  w:44, h:64,
  vx:0, vy:0,
  onGround:false,
  t:0
};

function resetPlayer(){
  const m = getWorldMetrics();
  player.w = m.playerW;
  player.h = m.playerH;
  player.x = Math.round(m.W*0.25);
  player.y = m.groundY - player.h;
  player.vx = 0;
  player.vy = 0;
  player.onGround = true;
  player.t = 0;
  state.worldX = 0;
  state.cameraX = 0;
}

/* =========================================================
   Input
   ========================================================= */
const input = {left:false, right:false, jump:false};

window.addEventListener("keydown",(e)=>{
  const k=e.code;
  if(["ArrowLeft","ArrowRight","ArrowUp","Space","KeyA","KeyD"].includes(k)) e.preventDefault();
  if(k==="ArrowLeft"||k==="KeyA") input.left=true;
  if(k==="ArrowRight"||k==="KeyD") input.right=true;
  if(k==="ArrowUp"||k==="Space") input.jump=true;
});
window.addEventListener("keyup",(e)=>{
  const k=e.code;
  if(k==="ArrowLeft"||k==="KeyA") input.left=false;
  if(k==="ArrowRight"||k==="KeyD") input.right=false;
});

function bindHold(btn, onDown, onUp){
  btn.addEventListener("pointerdown",(e)=>{ e.preventDefault(); onDown(); });
  btn.addEventListener("pointerup",(e)=>{ e.preventDefault(); onUp(); });
  btn.addEventListener("pointercancel",(e)=>{ e.preventDefault(); onUp(); });
}
bindHold(document.getElementById("leftBtn"), ()=>input.left=true, ()=>input.left=false);
bindHold(document.getElementById("rightBtn"),()=>input.right=true,()=>input.right=false);
document.getElementById("jumpBtn").addEventListener("pointerdown",(e)=>{ e.preventDefault(); input.jump=true; });

/* =========================================================
   Question UI
   ========================================================= */
function renderQuestion(q){
  state.current = q;
  topicBadge.textContent = q.topic;
  qTextEl.textContent = q.q;
  choicesEl.innerHTML = `
    <div class="choice"><div class="tag A">A</div><div><b>${escapeHtml(q.A)}</b></div></div>
    <div class="choice"><div class="tag B">B</div><div><b>${escapeHtml(q.B)}</b></div></div>
    <div class="choice"><div class="tag C">C</div><div><b>${escapeHtml(q.C)}</b></div></div>
  `;
}

function showPopup(ok, correctKey, why){
  popupEl.className = "pop " + (ok ? "good" : "bad");
  popupEl.style.display = "block";
  popupEl.innerHTML = (ok ? "✅ Correct! (+10)" : "❌ Wrong!") +
    `<span class="why">Correct: ${correctKey}. ${escapeHtml(why)}</span>`;
  setTimeout(()=> popupEl.style.display="none", FEEDBACK_MS);
}

/* =========================================================
   Blocks (A/B/C) — spaced along X (NOT continuous)
   ========================================================= */
function spawnOptionBlocks(){
  const m = getWorldMetrics();
  const blockH = clamp(Math.round(m.H*0.10), 40, 58);
  const blockW = clamp(Math.round(m.W*0.10), 68, 92);

  // "Appropriate spacing": big enough to land + decide
  const gap = clamp(Math.round(m.W*0.16), 110, 160);

  // spawn ahead so learner sees them coming (after read pause)
  const spawnWorldX = state.worldX + Math.round(m.W*0.75);

  const y = m.groundY - blockH;

  state.blocks = [
    makeBlock("A", spawnWorldX + 0*(blockW+gap), y, blockW, blockH),
    makeBlock("B", spawnWorldX + 1*(blockW+gap), y, blockW, blockH),
    makeBlock("C", spawnWorldX + 2*(blockW+gap), y, blockW, blockH),
  ];

  state.answered = false;
}

function makeBlock(key, x, y, w, h){
  const color = key==="A" ? css("--a") : key==="B" ? css("--b") : css("--c");
  return {key, x, y, w, h, color, hit:false, bounce:0};
}

/* =========================================================
   VFX
   ========================================================= */
function addFloatPop(worldX, y, text, color, ms=650){
  state.floatPop.push({x:worldX, y, text, color, until: performance.now()+ms});
}
function addBurst(worldX, y, color){
  for(let i=0;i<14;i++){
    const ang = Math.random()*Math.PI*2;
    const sp = 1.5 + Math.random()*2.6;
    state.particles.push({
      x:worldX, y,
      vx: Math.cos(ang)*sp,
      vy: Math.sin(ang)*sp - 1.2,
      born: performance.now(),
      life: 520 + Math.random()*260,
      color,
      r: 1.6 + Math.random()*2.4
    });
  }
}

/* =========================================================
   Collision (player vs block)
   We count collision when player hits front/side with forgiveness.
   ========================================================= */
function rectsOverlap(a,b){
  return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
}

function checkBlockCollisions(now){
  if(state.phase !== "question") return;
  if(state.answered) return;

  const m = getWorldMetrics();
  const pxWorldLeft = state.worldX + player.x - state.worldX; // keep simple: player.x is screen-space; worldX is tracked separately
  // Actually, our world system is: player stays around screen x, worldX increases.
  // The player's world x is state.worldX + player.x.
  const playerWorldX = state.worldX + player.x;

  const pr = {
    x: playerWorldX,
    y: player.y,
    w: player.w,
    h: player.h
  };

  for(const b of state.blocks){
    if(b.hit) continue;

    const br = {x:b.x, y:b.y, w:b.w, h:b.h};

    // forgiveness: shrink collision slightly so tiny corner touches don't punish
    const shrunk = {
      x: br.x + BLOCK_HIT_MARGIN,
      y: br.y + 2,
      w: br.w - 2*BLOCK_HIT_MARGIN,
      h: br.h - 4
    };

    if(rectsOverlap(pr, shrunk)){
      b.hit = true;
      b.bounce = now + 180;

      // handle answer
      handleAnswer(b.key);
      break;
    }
  }
}

/* =========================================================
   Answer / flow
   ========================================================= */
function handleAnswer(selectedKey){
  const q = state.current;
  const ok = (selectedKey === q.correct);

  state.attempted++;
  if(ok){
    state.correct++;
    state.score += 10;
    addFloatPop(state.worldX + player.x + player.w/2, player.y - 14, "+10", "rgba(57,217,138,.95)", 700);
    addBurst(state.worldX + player.x + player.w/2, player.y + 10, "rgba(57,217,138,.95)");
  }else{
    addFloatPop(state.worldX + player.x + player.w/2, player.y - 14, "0", "rgba(255,255,255,.85)", 650);
    addBurst(state.worldX + player.x + player.w/2, player.y + 10, "rgba(255,92,122,.95)");
  }

  updateHUD();
  showPopup(ok, q.correct, q.why);

  const rt = Math.max(0, Math.round(performance.now() - state.questionStart));
  state.log.push({
    ts: new Date().toISOString(),
    qid: q.id,
    topic: q.topic,
    selected: selectedKey,
    correct: q.correct,
    is_correct: ok ? 1 : 0,
    response_ms: rt,
    score_after: state.score
  });

  state.answered = true;
  state.phase = "feedback";

  setTimeout(()=> nextQuestion(), FEEDBACK_MS);
}

function autoNoAnswer(){
  if(state.phase !== "question") return;
  if(state.answered) return;

  const q = state.current;
  state.attempted++;
  updateHUD();
  showPopup(false, q.correct, "No answer recorded.");

  state.log.push({
    ts: new Date().toISOString(),
    qid: q.id,
    topic: q.topic,
    selected: "NA",
    correct: q.correct,
    is_correct: 0,
    response_ms: QUESTION_TIMEOUT_MS,
    score_after: state.score
  });

  state.phase = "feedback";
  state.answered = true;
  setTimeout(()=> nextQuestion(), FEEDBACK_MS);
}

function startQuestion(){
  if(state.qIndex >= state.questions.length){
    endGame();
    return;
  }
  const q = state.questions[state.qIndex++];
  renderQuestion(q);

  state.phase = "question";
  topicBadge.textContent = "Question";
  state.readUntil = performance.now() + READ_PAUSE_MS;
  state.questionStart = performance.now();
  state.blocks = [];
  state.answered = false;

  // after read pause, spawn blocks
  setTimeout(()=>{
    if(state.phase === "question" && !state.answered){
      spawnOptionBlocks();
    }
  }, READ_PAUSE_MS);

  // timeout
  setTimeout(()=> autoNoAnswer(), QUESTION_TIMEOUT_MS);
}

function nextQuestion(){
  popupEl.style.display="none";
  state.blocks = [];
  state.phase = "run";
  topicBadge.textContent = "Running";

  // tiny gap before next question
  setTimeout(()=> startQuestion(), 650);
}

/* =========================================================
   Drawing
   ========================================================= */
function roundRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function drawSky(now, W, H){
  // stars
  for(const s of stars){
    const tw = 0.45 + 0.55*Math.sin(now/700 + s.tw);
    ctx.globalAlpha = 0.25 + tw*0.65;
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // soft hills
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "rgba(100,181,255,.9)";
  ctx.beginPath();
  ctx.ellipse(W*0.15, H*0.95, W*0.55, H*0.55, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(W*0.92, H*1.02, W*0.55, H*0.45, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // subtle horizon glow
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,"rgba(255,255,255,.06)");
  g.addColorStop(0.55,"rgba(255,255,255,.00)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);
}

function drawGround(W, H, groundY, thick){
  // ground
  const base = ctx.createLinearGradient(0, groundY, 0, groundY+thick);
  base.addColorStop(0, "rgba(46,101,196,.92)");
  base.addColorStop(1, "rgba(20,35,74,.92)");
  ctx.fillStyle = base;
  roundRect(0, groundY, W, thick, 16);
  ctx.fill();

  // tile-ish pattern
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = "white";
  for(let x=16; x<W; x+=34){
    ctx.fillRect(x, groundY+18, 14, 10);
  }
  ctx.globalAlpha = 1;
}

function drawPlayer(now){
  // improved silhouette: head/helmet + body + legs + outline
  player.t += 0.12 + Math.min(0.20, Math.abs(player.vx)*0.08);

  const x = player.x;
  const y = player.y;
  const w = player.w;
  const h = player.h;

  // shadow
  ctx.fillStyle="rgba(0,0,0,.30)";
  ctx.beginPath();
  ctx.ellipse(x+w*0.5, y+h+10, w*0.42, 6, 0, 0, Math.PI*2);
  ctx.fill();

  // helmet (bigger, clearer)
  const headR = Math.max(14, w*0.45);
  const hx = x + w*0.5;
  const hy = y + h*0.28;

  const headGrad = ctx.createLinearGradient(hx-headR, hy-headR, hx+headR, hy+headR);
  headGrad.addColorStop(0,"rgba(255,255,255,.98)");
  headGrad.addColorStop(1,"rgba(170,210,255,.85)");
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.arc(hx, hy, headR, 0, Math.PI*2);
  ctx.fill();

  // visor
  const vg = ctx.createLinearGradient(hx-headR*0.6, hy-headR*0.2, hx+headR*0.6, hy+headR*0.4);
  vg.addColorStop(0,"rgba(51,214,255,.70)");
  vg.addColorStop(1,"rgba(124,92,255,.55)");
  ctx.fillStyle = vg;
  roundRect(hx-headR*0.62, hy-headR*0.18, headR*1.24, headR*0.56, 10);
  ctx.fill();

  // body (clear torso)
  const bodyTop = y + h*0.42;
  const bodyH = h*0.52;
  const bodyGrad = ctx.createLinearGradient(x, bodyTop, x, bodyTop+bodyH);
  bodyGrad.addColorStop(0,"rgba(235,245,255,.95)");
  bodyGrad.addColorStop(1,"rgba(150,195,255,.80)");
  ctx.fillStyle = bodyGrad;
  roundRect(x+w*0.10, bodyTop, w*0.80, bodyH, 16);
  ctx.fill();

  // belt
  ctx.globalAlpha = 0.55;
  ctx.fillStyle="rgba(7,16,37,.92)";
  roundRect(x+w*0.18, bodyTop+bodyH*0.45, w*0.64, 8, 6);
  ctx.fill();
  ctx.globalAlpha = 1;

  // arms (chunkier for visibility)
  const armSwing = Math.sin(player.t)*6;
  ctx.strokeStyle="rgba(255,255,255,.85)";
  ctx.lineWidth = Math.max(5, w*0.14);
  ctx.lineCap="round";
  ctx.beginPath();
  ctx.moveTo(x+w*0.18, bodyTop+bodyH*0.22);
  ctx.lineTo(x+w*0.10, bodyTop+bodyH*0.40 + armSwing*0.10);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x+w*0.82, bodyTop+bodyH*0.22);
  ctx.lineTo(x+w*0.90, bodyTop+bodyH*0.40 - armSwing*0.10);
  ctx.stroke();

  // legs (more visible)
  const step = Math.sin(player.t)*7;
  ctx.strokeStyle="rgba(255,255,255,.90)";
  ctx.lineWidth = Math.max(6, w*0.16);
  ctx.beginPath();
  ctx.moveTo(x+w*0.36, y+h-6);
  ctx.lineTo(x+w*0.36 + step*0.45, y+h+10);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x+w*0.64, y+h-6);
  ctx.lineTo(x+w*0.64 - step*0.45, y+h+10);
  ctx.stroke();

  // outline (high contrast)
  ctx.strokeStyle="rgba(100,181,255,.55)";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.arc(hx, hy, headR, 0, Math.PI*2);
  ctx.stroke();
  roundRect(x+w*0.10, bodyTop, w*0.80, bodyH, 16);
  ctx.stroke();
}

function drawBlocks(now){
  const cam = state.cameraX;

  for(const b of state.blocks){
    const bounce = (b.bounce && b.bounce > now) ? Math.sin((1 - (b.bounce - now)/180)*Math.PI)*10 : 0;
    const sx = b.x - cam;
    const sy = b.y - bounce;

    // glow
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = b.color;
    roundRect(sx-6, sy-6, b.w+12, b.h+12, 14);
    ctx.fill();
    ctx.globalAlpha = 1;

    // block body
    const grad = ctx.createLinearGradient(sx,sy,sx,sy+b.h);
    grad.addColorStop(0, b.color);
    grad.addColorStop(1, "rgba(0,0,0,.10)");
    ctx.fillStyle = grad;
    roundRect(sx, sy, b.w, b.h, 12);
    ctx.fill();

    // bevel
    ctx.globalAlpha = 0.55;
    ctx.strokeStyle = "rgba(255,255,255,.55)";
    ctx.lineWidth = 2;
    roundRect(sx+3, sy+3, b.w-6, b.h-6, 10);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // label
    ctx.fillStyle = "rgba(7,16,37,.92)";
    ctx.font = "950 22px system-ui,Segoe UI,Arial";
    ctx.fillText(b.key, sx + b.w/2 - 7, sy + b.h/2 + 8);
  }
}

function drawFloatPops(now){
  state.floatPop = state.floatPop.filter(p => now < p.until);
  for(const p of state.floatPop){
    const t = 1 - ((p.until - now)/650);
    const sx = (p.x - state.cameraX);
    ctx.globalAlpha = 1 - t;
    ctx.fillStyle = p.color;
    ctx.font = "900 14px system-ui,Segoe UI,Arial";
    ctx.fillText(p.text, sx, p.y - t*18);
    ctx.globalAlpha = 1;
  }
}

function drawParticles(now){
  state.particles = state.particles.filter(pt => (now - pt.born) < pt.life);
  for(const pt of state.particles){
    const age = now - pt.born;
    const t = age / pt.life;
    pt.x += pt.vx;
    pt.y += pt.vy;
    pt.vy += 0.06;

    const sx = pt.x - state.cameraX;
    ctx.globalAlpha = 1 - t;
    ctx.fillStyle = pt.color;
    ctx.beginPath();
    ctx.arc(sx, pt.y, pt.r, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function drawHint(now, W, H){
  if(state.phase === "question"){
    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.fillRect(0, H-40, W, 40);
    ctx.fillStyle = "rgba(234,240,255,.92)";
    ctx.font = "900 12px system-ui,Segoe UI,Arial";
    ctx.fillText("Answer: collide with correct block A/B/C. Jump over wrong ones.", 12, H-16);
  }
}

function draw(now){
  const m = getWorldMetrics();
  const W = m.W, H = m.H;

  ctx.clearRect(0,0,W,H);

  drawSky(now, W, H);

  // ground
  drawGround(W, H, m.groundY, m.groundThickness);

  // blocks + effects are in world-space (camera translate done by subtracting cameraX)
  drawBlocks(now);
  drawParticles(now);
  drawFloatPops(now);

  // player is in screen-space (always visible)
  drawPlayer(now);

  drawHint(now, W, H);
}

/* =========================================================
   Physics + camera (player ALWAYS visible)
   ========================================================= */
function step(now){
  if(!state.running) return;

  const m = getWorldMetrics();
  const groundY = m.groundY;

  // reading pause: freeze forward motion so learners can read
  const inReadPause = (state.phase === "question" && now < state.readUntil);

  // forward progression: worldX moves, player mostly stays in place on screen
  const forward = (!inReadPause && (state.phase === "run" || state.phase === "question")) ? RUN_SPEED : 0;
  state.worldX += forward;

  // small left/right adjust (screen-space)
  const ctl = player.onGround ? GROUND_CONTROL : AIR_CONTROL;
  if(input.left)  player.vx -= ctl;
  if(input.right) player.vx += ctl;
  player.vx *= 0.88;
  player.vx = clamp(player.vx, -3.2, 3.2);

  // jump
  if(input.jump){
    input.jump = false;
    if(player.onGround){
      player.vy = JUMP_VEL;
      player.onGround = false;
      addBurst(state.worldX + player.x + player.w/2, player.y + player.h, "rgba(255,255,255,.75)");
    }
  }

  // gravity
  player.vy += GRAVITY;
  player.vy = Math.min(player.vy, 18);

  // integrate
  player.x += player.vx;
  player.y += player.vy;

  // keep player within visible screen
  player.x = clamp(player.x, 24, m.W - player.w - 24);

  // ground collision
  const floor = groundY - player.h;
  if(player.y >= floor){
    player.y = floor;
    player.vy = 0;
    player.onGround = true;
  }

  // camera follows world, keeping player area stable
  // The cameraX is simply worldX (so blocks scroll towards player)
  state.cameraX = state.worldX;

  // if blocks exist and player passes beyond last block without hitting -> NA
  if(state.phase === "question" && state.blocks.length){
    const last = state.blocks[state.blocks.length-1];
    const playerWorldX = state.worldX + player.x;
    if(!state.answered && playerWorldX > last.x + last.w + 60){
      autoNoAnswer();
    }
  }

  // collision with blocks
  checkBlockCollisions(now);
}

/* =========================================================
   Game start / end
   ========================================================= */
function prepareQuestions(){
  state.questions = shuffle(QUESTION_BANK).slice(0, Math.min(QUESTIONS_PER_RUN, QUESTION_BANK.length));
  state.qIndex = 0;
  qtotalEl.textContent = String(state.questions.length);
}

function boot(){
  state.running = false;
  state.phase = "menu";

  state.score = 0;
  state.coins = 0;
  state.correct = 0;
  state.attempted = 0;

  state.qIndex = 0;
  state.current = null;

  state.cameraX = 0;
  state.worldX = 0;

  state.blocks = [];
  state.answered = false;

  state.floatPop = [];
  state.particles = [];
  state.log = [];

  popupEl.style.display = "none";
  topicBadge.textContent = "Ready";
  qTextEl.textContent = "Press Start to begin.";
  choicesEl.innerHTML = "";

  prepareQuestions();
  updateHUD();
  resetPlayer();
}

function startGame(){
  overlay.style.display = "none";
  state.running = true;
  state.phase = "run";
  topicBadge.textContent = "Running";
  qTextEl.textContent = "Get ready. First question starts now.";
  choicesEl.innerHTML = "";

  // start first question after short warm-up
  setTimeout(()=> startQuestion(), 650);
}

function endGame(){
  state.running = false;
  state.phase = "end";

  const acc = state.attempted ? Math.round((state.correct/state.attempted)*100) : 0;
  modalTitle.textContent = "Run Completed";
  modalBody.innerHTML = `
    <p><b>Score:</b> ${state.score} &nbsp; | &nbsp; <b>Accuracy:</b> ${acc}% &nbsp; | &nbsp; <b>Attempted:</b> ${state.attempted}</p>
    <p class="muted">Download CSV for analysis.</p>
    <div class="row" style="justify-content:flex-start; margin-top:10px; gap:10px;">
      <button class="btn" id="dlBtn">Download CSV</button>
    </div>
  `;
  overlay.style.display = "flex";
  setTimeout(()=> document.getElementById("dlBtn").onclick = downloadCSV, 0);
}

function downloadCSV(){
  const rows = [["ts","qid","topic","selected","correct","is_correct","response_ms","score_after"]];
  for(const r of state.log){
    rows.push([r.ts,r.qid,r.topic,r.selected,r.correct,r.is_correct,r.response_ms,r.score_after]);
  }
  const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download="GBL_Runner_v5_Log.csv";
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* =========================================================
   Buttons
   ========================================================= */
document.getElementById("restartBtn").onclick = ()=> { overlay.style.display="none"; boot(); };
document.getElementById("startBtn").onclick = ()=> { if(!state.running) startGame(); };

/* =========================================================
   Loop
   ========================================================= */
function loop(now){
  step(now);
  draw(now);
  requestAnimationFrame(loop);
}

/* =========================================================
   Init
   ========================================================= */
fitCanvas();
initSky();
boot();
requestAnimationFrame(loop);
</script>
</body>
</html>
```
